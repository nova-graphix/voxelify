var g0 = Object.defineProperty;
var y0 = (f, t, e) => t in f ? g0(f, t, { enumerable: !0, configurable: !0, writable: !0, value: e }) : f[t] = e;
var j = (f, t, e) => y0(f, typeof t != "symbol" ? t + "" : t, e);
import { Matrix4 as m0, Vector3 as F, Vector4 as V0, Mesh as c0, TextureLoader as l0, InstancedBufferGeometry as O0, BufferAttribute as h0, InstancedBufferAttribute as Q, MeshStandardMaterial as M0, Vector2 as p0, BoxGeometry as S0, MeshBasicMaterial as E0, Group as L0, Box3Helper as R0, Box3 as f0, ArrowHelper as w0, Sphere as C0, MathUtils as B } from "three";
import { SimplexNoise as b0 } from "three/examples/jsm/math/SimplexNoise";
const z0 = (f, t = 0, e = 1) => Math.max(t, Math.min(e, f));
function T0() {
  this.xsize = 0, this.ysize = 0, this.zsize = 0, this.vcount = 0, this.voxels = {}, this.palette = null, this.setVoxel = function(f, t, e, o) {
    o |= 0, f |= 0, t |= 0, e |= 0, this.xsize = 256, this.ysize = 256, this.zsize = 256;
    var s = f + "_" + t + "_" + e;
    o > 0 ? (this.voxels[s] || this.vcount++, this.voxels[s] = o) : this.voxels[s] && (this.vcount--, delete this.voxels[s]);
  }, this.setPalette = function(f) {
    this.palette = f;
  }, this.appendString = function(f, t) {
    for (var e = 0, o = t.length; e < o; e++)
      f.push(t.charCodeAt(e));
  }, this.appendUInt32 = function(f, t) {
    f.push(t & 255, t >>> 8 & 255, t >>> 16 & 255, t >>> 24 & 255);
  }, this.appendRGBA = function(f, t) {
    f.push(t >>> 16 & 255, t >>> 8 & 255, t & 255, t >>> 24 & 255);
  }, this.appendVoxel = function(f, t) {
    const e = t.split("_");
    f.push(e[0], e[1], e[2], this.voxels[t]);
  }, this.export = function(f) {
    var t = [];
    this.appendString(t, "VOX "), this.appendUInt32(t, 150), this.appendString(t, "MAIN"), this.appendUInt32(t, 0), this.appendUInt32(t, this.vcount * 4 + 1076), this.appendString(t, "SIZE"), this.appendUInt32(t, 12), this.appendUInt32(t, 0), this.appendUInt32(t, this.xsize), this.appendUInt32(t, this.ysize), this.appendUInt32(t, this.zsize), this.appendString(t, "XYZI"), this.appendUInt32(t, 4 + this.vcount * 4), this.appendUInt32(t, 0), this.appendUInt32(t, this.vcount);
    for (let e in this.voxels)
      this.appendVoxel(t, e);
    if (this.palette) {
      this.appendString(t, "RGBA"), this.appendUInt32(t, 1024), this.appendUInt32(t, 0);
      for (let e = 0; e < 256; e++)
        this.appendRGBA(t, this.palette[e]);
    }
    this.saveByteArray([new Uint8Array(t)], f);
  }, this.saveByteArray = function() {
    var f = document.createElement("a");
    return document.body.appendChild(f), f.style = "display: none", function(t, e) {
      var o = new Blob(t, { type: "octet/stream" }), s = window.URL.createObjectURL(o);
      f.href = s, f.download = e, f.click(), window.URL.revokeObjectURL(s);
    };
  }();
}
function A0(f, t = 8) {
  const e = Math.pow(2, t), o = {};
  f.forEach((i) => {
    const c = i[0] + "_" + i[1] + "_" + i[2];
    o[c] || (o[c] = 1);
  });
  const s = [];
  if (Object.keys(o).forEach((i) => {
    i = i.split("_").map((c) => parseInt(c)), s.push(i);
  }), s.length <= e) {
    const i = e - s.length;
    for (let c = 0; c < i; c++) s.push([0, 0, 0]);
    return s;
  }
  const n = (i) => {
    let c = [];
    for (let h = 0; h < 3; h++) {
      const l = i.map((u) => u[h]);
      c.push(l.max() - l.min());
    }
    return c.indexOf(Math.min(...c));
  }, r = (i, c) => {
    if (i.length === 0)
      return [[0, 0, 0]];
    if (c === t) {
      const u = i.reduce((p, d) => (p[0] += d[0], p[1] += d[1], p[2] += d[2], p), [0, 0, 0]);
      return u[0] = Math.round(u[0] / i.length), u[1] = Math.round(u[1] / i.length), u[2] = Math.round(u[2] / i.length), [u];
    }
    const h = n(i);
    i.sort((u, p) => u[h] - p[h]);
    const l = Math.floor(i.length / 2);
    return [
      ...r(i.slice(0, l), c + 1),
      ...r(i.slice(l + 1), c + 1)
    ];
  };
  return r(s, 0);
}
class D0 {
  createPalette(t) {
    const e = t.geometry.attributes.aVoxData.array;
    let o = [];
    for (let n = 0, r = e.length; n < r; n += 4) {
      const a = e[n + 1], i = a >> 16 & 255, c = a >> 8 & 255, h = a & 255;
      o.push([i, c, h]);
    }
    return A0(o, 8);
  }
  saveVoxelMesh(t, e) {
    var o = new T0();
    let s = this.createPalette(t);
    s = [[0, 0, 0], ...s], s.pop();
    const n = t.geometry.attributes.aVoxData.array, r = t.voxDim;
    for (let i = 0, c = n.length; i < c; i += r) {
      const h = n[i], l = h >> 16 & 255, u = h >> 8 & 255, p = h & 255, d = n[i + 1], R = d >> 16 & 255, y = d >> 8 & 255, M = d & 255, x = s.map((V) => this.colorDistance(V, [R, y, M]));
      let v = x.indexOf(Math.min(...x));
      v === 255 && (x.pop(), v = x.indexOf(Math.min(...x))), o.setVoxel(p, 255 - l, u, v + 1);
    }
    const a = [];
    for (let i = 0; i < 256; i++) {
      const [c, h, l] = this.linearToSRGB(s[i]), u = c << 16 ^ h << 8 ^ l;
      a.push(u);
    }
    o.setPalette(a), o.export(e);
  }
  save(t, e) {
    const o = [];
    if (t.traverse((s) => {
      s.isVoxelMesh && o.push(s);
    }), o.length === 0) {
      console.log(">> VoxelMesh not found in your object...");
      return;
    } else if (o.length === 1)
      this.saveVoxelMesh(o[0], e);
    else {
      const s = e.split(".")[0];
      o.forEach((n, r) => {
        this.saveVoxelMesh(n, s + "_" + (r + 1) + ".vox");
      });
    }
  }
  linearToSRGB(t) {
    for (let e = 0; e < 3; e++) {
      const o = LinearToSRGB(t[e] / 255);
      t[e] = z0(~~(o * 255), 0, 255);
    }
    return t;
  }
  colorDistance(t, e) {
    const o = (t[0] + e[0]) / 2, s = t[0] - e[0], n = t[1] - e[1], r = t[2] - e[2];
    return Math.sqrt(((512 + o) * s * s >> 8) + 4 * n * n + ((767 - o) * r * r >> 8));
  }
}
const N0 = (f) => f < 0.04045 ? f * 0.0773993808 : Math.pow(f * 0.9478672986 + 0.0521327014, 2.4), t0 = (f, t = 0, e = 1) => Math.max(t, Math.min(e, f)), x0 = new m0(), I = new F(), $ = new F(), H = new F(), I0 = new V0(), X = new F();
let Y = null, P = null, G = null;
const e0 = 65536, o0 = 256, s0 = 1, n0 = [
  1,
  2,
  4,
  8,
  16,
  32,
  64,
  128,
  256,
  512,
  1024,
  2048,
  4096,
  8192,
  16384,
  32768,
  65536,
  131072,
  262144,
  524288,
  1048576,
  2097152,
  4194304,
  8388608,
  16777216,
  33554432,
  67108864,
  134217728,
  268435456,
  536870912,
  1073741824,
  2147483648
], C = class C extends c0 {
  // where
  // 'pnz' ===> (+X -Y  0)
  // 'npp' ===> (-X +Y +Z)
  constructor() {
    super(), this.isVoxelMesh = !0, this.options = {
      voxMapType: "stringVoxMap",
      // 'stringVoxMap', 'uintVoxMap'
      shelling: !0
      // kill the voxels inside
    }, this.voxMap = /* @__PURE__ */ new Map(), this.voxDim = 2, this.voxType = "cube", this.atlas = null, this._origin = [1 / 0, 1 / 0, 1 / 0];
  }
  // texture
  setAtlasTexture(t) {
    this.atlas = t, t.uvScale || (t.tileSize && t.texSize ? t.uvScale = [
      t.tileSize.x / t.texSize.x,
      t.tileSize.y / t.texSize.y
    ] : t.uvScale = [1, 1 / 3]);
    const e = new l0();
    t.diffuseMap || (t.diffuseMap = t.diffuseURL ? e.load(t.diffuseURL) : null), t.normalMap || (t.normalMap = t.normalURL ? e.load(t.normalURL) : null);
  }
  // voxMap
  vp_to_xyz(t) {
    if (typeof t == "string")
      return t.split(",").map((e) => parseInt(e));
    {
      const e = t >> 24 & 255, o = t >> 16 & 255, s = t >> 8 & 255;
      return [t & 255, s, o, e];
    }
  }
  xyz_to_vp(t, e, o, s = 0) {
    return t = Math.round(t), e = Math.round(e), o = Math.round(o), this.options.voxMapType === "stringVoxMap" ? `${t},${e},${o}` : ((t < 0 || t > 255 || e < 0 || e > 255 || o < 0 || o > 255) && (t = t0(t, 0, 255), e = t0(e, 0, 255), o = t0(o, 0, 255)), s << 24 ^ o << 16 ^ e << 8 ^ t << 0);
  }
  // static functions
  // basic: (x,y,z) = 0 ~ 255
  static _get_x(t) {
    return t & 255;
  }
  static _get_y(t) {
    return t >> 8 & 255;
  }
  static _get_z(t) {
    return t >> 16 & 255;
  }
  static _set_x(t, e) {
    return t & 16776960 | e;
  }
  static _set_y(t, e) {
    return t & 16711935 | e << 8;
  }
  static _set_z(t, e) {
    return t & 65535 | e << 16;
  }
  // vp: (x,y,z) = 0 ~ 255 (= ff)
  static get_xyz(t) {
    return [t & 255, t >> 8 & 255, t >> 16 & 255];
  }
  static get_vp(t, e, o) {
    return o << 16 ^ e << 8 ^ t;
  }
  // vp: (x,y,z) = 0 ~ 127 (= 7f)
  static get_xyz_128(t) {
    return [t & 127, t >> 7 & 127, t >> 14 & 127];
  }
  static get_vp_128(t, e, o) {
    return o << 14 ^ e << 7 ^ t;
  }
  // vp: (x,y,z) = 0 ~ 63 (= 3f)
  static get_xyz_64(t) {
    return [t & 63, t >> 6 & 63, t >> 12 & 63];
  }
  static get_vp_64(t, e, o) {
    return o << 12 ^ e << 6 ^ t;
  }
  // vc: col = hexCol = 0xrrggbb
  static get_col(t) {
    return t & 16777215;
  }
  static set_col(t, e) {
    return t & 0 | e;
  }
  // vs: (size, opacity, life) = 0 ~ 255
  static get_size(t) {
    return C._get_x(t);
  }
  static get_opacity(t) {
    return C._get_y(t);
  }
  static get_life(t) {
    return C._get_z(t);
  }
  static set_size(t, e) {
    return C._set_x(t, e);
  }
  static set_opacity(t, e) {
    return C._set_y(t, e);
  }
  static set_life(t, e) {
    return C._set_z(t, e);
  }
  // vox default
  static voxDefault(t = 2) {
    let e = { vi: 0, vc: 16777215 };
    return t >= 3 && (e = { ...e, vs: 16776961 }), t >= 4 && (e = { ...e, vr: 0 }), e;
  }
  // vox size
  static getVoxSize(t) {
    return C._get_x(t.vs);
  }
  static getVoxOpacity(t) {
    return C._get_y(t.vs);
  }
  static getVoxLife(t) {
    return C._get_z(t.vs);
  }
  static setVoxSize(t, e) {
    t.vs = C._set_x(t.vs, e);
  }
  static setVoxOpacity(t, e) {
    t.vs = C._set_y(t.vs, e);
  }
  static setVoxLife(t, e) {
    t.vs = C._set_z(t.vs, e);
  }
  //
  initVoxMap() {
    this.clearVoxMap(), this.voxMap = /* @__PURE__ */ new Map();
  }
  clearVoxMap() {
    this.voxMap && (this.voxMap.clear(), this.voxMap = null);
  }
  regenVoxMap() {
    var e;
    this.clearVoxMap();
    const t = (e = this.geometry.attributes.aVoxData) == null ? void 0 : e.array;
    if (t) {
      const o = this.voxDim, s = /* @__PURE__ */ new Map();
      for (let n = 0, r = t.length; n < r; n += o) {
        let a = { vi: n, vc: t[n + 1] };
        o >= 3 && (a = { ...a, vs: t[n + 2] }), o >= 4 && (a = { ...a, vr: t[n + 3] }), s.set(t[n], a);
      }
      this.voxMap = s;
    }
  }
  // voxel
  setVoxel(t, e, o, s) {
    if (!this.getVoxel(t, e, o)) {
      const n = this._origin;
      n[0] = Math.min(n[0], t), n[1] = Math.min(n[1], e), n[2] = Math.min(n[2], o);
      const r = this.xyz_to_vp(t, e, o);
      if (r) {
        let a, i, c;
        const h = s.length;
        h >= 1 && (a = s[0]), h >= 2 && (a = s[1] << 24 ^ s[0] << 0), h >= 5 && (i = s[4] << 16 ^ s[3] << 8 ^ s[2] << 0), h >= 8 && (c = s[7] << 16 ^ s[6] << 8 ^ s[5] << 0), this.voxMap.set(r, { vc: a, vs: i, vr: c });
      }
    }
  }
  getVoxel(t, e, o) {
    const s = this.xyz_to_vp(t, e, o);
    return s ? this.voxMap.get(s) : null;
  }
  // voxel position
  getVoxelPos(t) {
    return I.copy(t), this.world_to_local(I), this.xyz_to_vp(I.x, I.y, I.z);
  }
  // boundary
  isBoundary(t, e) {
    const o = this.vp_to_xyz(t), s = o[0] === 0 || o[0] === 255, n = o[1] === 0 || o[1] === 255, r = o[2] === 0 || o[2] === 255;
    switch (e) {
      case "x":
        if (s) return !0;
      case "y":
        if (n) return !0;
      case "z":
        if (r) return !0;
      case "xy":
        if (s && n) return !0;
      case "yz":
        if (n && r) return !0;
      case "zx":
        if (r && s) return !0;
      case "xyz":
        if (s && n && r) return !0;
    }
    return !1;
  }
  // find voxel
  findVoxelPos(t, e) {
    return Array.isArray(e) ? t += e[0] * s0 + e[1] * o0 + e[2] * e0 : typeof e == "string" && (e = e.split(""), e[0] === "p" ? t += s0 : e[0] === "n" && (t -= s0), e[1] === "p" ? t += o0 : e[1] === "n" && (t -= o0), e[2] === "p" ? t += e0 : e[2] === "n" && (t -= e0)), t;
  }
  findVoxel(t, e) {
    return t = this.findVoxelPos(t, e), this.voxMap.has(t) ? t : null;
  }
  // find neighbors
  findFaceNeighbors(t) {
    const e = [];
    for (let o = 0; o < 6; o++)
      e.push(this.findVoxel(t, C.Faces[o]));
    return e;
  }
  findEdgeNeighbors(t) {
    const e = [];
    for (let o = 0; o < 12; o++)
      e.push(this.findVoxel(t, C.Edges[o]));
    return e;
  }
  findVertexNeighbors(t) {
    const e = [];
    for (let o = 0; o < 8; o++)
      e.push(this.findVoxel(t, C.Vertices[o]));
    return e;
  }
  findAllNeighbors(t) {
    const e = [];
    return e.push(...this.findFaceNeighbors(t)), e.push(...this.findEdgeNeighbors(t)), e.push(...this.findVertexNeighbors(t)), [...new Set(e).values()];
  }
  // edit voxMap ==> update aVoxData (and aVoxNB if needed)
  deleteVoxels(t) {
    const e = this.voxMap;
    t.forEach((o) => e.delete(o)), this.__updateFromVoxMap();
  }
  addVoxels(t) {
    const e = this.voxMap;
    t.forEach((o) => e.set(o[0], o[1])), this.__updateFromVoxMap();
  }
  // voxel nb
  __findVoxNB(t) {
    let e, o = 0;
    e = this.findFaceNeighbors(t);
    for (let s = 0; s < 6; s++)
      e[s] && (o |= n0[s]);
    e = this.findEdgeNeighbors(t);
    for (let s = 0; s < 12; s++)
      e[s] && (o |= n0[6 + s]);
    e = this.findVertexNeighbors(t);
    for (let s = 0; s < 8; s++)
      e[s] && (o |= n0[18 + s]);
    return o;
  }
  __findAllVoxNB() {
    const t = [], e = this.voxMap;
    for (const o of e.keys())
      t.push(this.__findVoxNB(o));
    return t;
  }
  // mesh
  __fillVoxelMesh() {
    function t(e, o, s, n) {
      o = e.findVoxelPos(o, s), e.voxMap.set(o, { vc: n });
    }
    for (let e = 0; e < 2; e++) {
      const o = this.voxMap, s = Array.from(o);
      for (const [n, { vc: r }] of s) {
        if (this.isBoundary(n, "x") || this.isBoundary(n, "z")) continue;
        const i = this.findEdgeNeighbors(n).map((c) => c !== null);
        for (let c = 0; c < 12; c += 4) {
          const h = i[c] || i[c + 1], l = i[c + 2] || i[c + 3];
          h && l || (h || (i[c] ? t(this, n, C.Edges[c + 1], r) : t(this, n, C.Edges[c], r)), l || (i[c + 2] ? t(this, n, C.Edges[c + 3], r) : t(this, n, C.Edges[c + 2], r)));
        }
      }
    }
    this.__updateFromVoxMap();
  }
  __shellVoxelMesh() {
    const t = /* @__PURE__ */ new Map(), e = this.voxMap;
    let o;
    for (const s of e.keys()) {
      const n = this.vp_to_xyz(s), r = n[0], a = n[1], i = n[2];
      t.set(s, !1);
      for (let c = 0; c < 6; c++) {
        switch (c) {
          case 0:
            o = this.xyz_to_vp(r + 1, a, i);
            break;
          case 1:
            o = this.xyz_to_vp(r, a + 1, i);
            break;
          case 2:
            o = this.xyz_to_vp(r, a, i + 1);
            break;
          case 3:
            o = this.xyz_to_vp(r - 1, a, i);
            break;
          case 4:
            o = this.xyz_to_vp(r, a - 1, i);
            break;
          case 5:
            o = this.xyz_to_vp(r, a, i - 1);
            break;
        }
        if (!e.get(o)) {
          t.set(s, !0);
          break;
        }
      }
    }
    for (const [s, n] of t.entries())
      n || e.delete(s);
  }
  __prepareVoxelMesh() {
    this.options.shelling === !0 && this.__shellVoxelMesh();
    const t = this._origin[0], e = this._origin[1], o = this._origin[2], s = this.voxMap, n = /* @__PURE__ */ new Map(), r = this;
    let a, i;
    r.options.voxMapType = "uintVoxMap", Array.from(s).forEach((c) => {
      i = r.vp_to_xyz(c[0]), i[0] = i[0] - t, i[1] = i[1] - e, i[2] = i[2] - o, a = r.xyz_to_vp(i[0], i[1], i[2]), a && n.set(a, c[1]);
    }), this.voxMap = n, this.position.set(t, e, o);
  }
  __createVoxMeshGeometry(t = null) {
    t || (t = this.voxMap);
    const e = t.size, o = new O0();
    o.instanceCount = e;
    let s, n;
    this.voxType === "cube" ? (n = [
      0,
      1,
      2,
      2,
      1,
      3,
      // Left   = 0
      4,
      5,
      6,
      6,
      5,
      7,
      // Right  = 1
      8,
      9,
      10,
      10,
      9,
      11,
      // Bottom = 2
      12,
      13,
      14,
      14,
      13,
      15,
      // Top    = 3
      16,
      17,
      18,
      18,
      17,
      19,
      // Back   = 4
      20,
      21,
      22,
      22,
      21,
      23
      // Front  = 5
    ], s = 24) : this.voxType === "box" ? (n = [0, 2, 1, 2, 3, 1, 4, 6, 5, 6, 7, 5, 8, 10, 9, 10, 11, 9, 12, 14, 13, 14, 15, 13, 16, 18, 17, 18, 19, 17, 20, 22, 21, 22, 23, 21], s = 24) : this.voxType === "sphere8" ? (n = [0, 9, 10, 1, 10, 11, 2, 11, 12, 3, 12, 13, 4, 13, 14, 5, 14, 15, 6, 15, 16, 7, 16, 17, 10, 9, 19, 9, 18, 19, 11, 10, 20, 10, 19, 20, 12, 11, 21, 11, 20, 21, 13, 12, 22, 12, 21, 22, 14, 13, 23, 13, 22, 23, 15, 14, 24, 14, 23, 24, 16, 15, 25, 15, 24, 25, 17, 16, 26, 16, 25, 26, 19, 18, 28, 18, 27, 28, 20, 19, 29, 19, 28, 29, 21, 20, 30, 20, 29, 30, 22, 21, 31, 21, 30, 31, 23, 22, 32, 22, 31, 32, 24, 23, 33, 23, 32, 33, 25, 24, 34, 24, 33, 34, 26, 25, 35, 25, 34, 35, 28, 27, 37, 29, 28, 38, 30, 29, 39, 31, 30, 40, 32, 31, 41, 33, 32, 42, 34, 33, 43, 35, 34, 44], s = 45) : this.voxType === "sphere" ? (n = [0, 17, 18, 1, 18, 19, 2, 19, 20, 3, 20, 21, 4, 21, 22, 5, 22, 23, 6, 23, 24, 7, 24, 25, 8, 25, 26, 9, 26, 27, 10, 27, 28, 11, 28, 29, 12, 29, 30, 13, 30, 31, 14, 31, 32, 15, 32, 33, 18, 17, 35, 17, 34, 35, 19, 18, 36, 18, 35, 36, 20, 19, 37, 19, 36, 37, 21, 20, 38, 20, 37, 38, 22, 21, 39, 21, 38, 39, 23, 22, 40, 22, 39, 40, 24, 23, 41, 23, 40, 41, 25, 24, 42, 24, 41, 42, 26, 25, 43, 25, 42, 43, 27, 26, 44, 26, 43, 44, 28, 27, 45, 27, 44, 45, 29, 28, 46, 28, 45, 46, 30, 29, 47, 29, 46, 47, 31, 30, 48, 30, 47, 48, 32, 31, 49, 31, 48, 49, 33, 32, 50, 32, 49, 50, 35, 34, 52, 34, 51, 52, 36, 35, 53, 35, 52, 53, 37, 36, 54, 36, 53, 54, 38, 37, 55, 37, 54, 55, 39, 38, 56, 38, 55, 56, 40, 39, 57, 39, 56, 57, 41, 40, 58, 40, 57, 58, 42, 41, 59, 41, 58, 59, 43, 42, 60, 42, 59, 60, 44, 43, 61, 43, 60, 61, 45, 44, 62, 44, 61, 62, 46, 45, 63, 45, 62, 63, 47, 46, 64, 46, 63, 64, 48, 47, 65, 47, 64, 65, 49, 48, 66, 48, 65, 66, 50, 49, 67, 49, 66, 67, 52, 51, 69, 51, 68, 69, 53, 52, 70, 52, 69, 70, 54, 53, 71, 53, 70, 71, 55, 54, 72, 54, 71, 72, 56, 55, 73, 55, 72, 73, 57, 56, 74, 56, 73, 74, 58, 57, 75, 57, 74, 75, 59, 58, 76, 58, 75, 76, 60, 59, 77, 59, 76, 77, 61, 60, 78, 60, 77, 78, 62, 61, 79, 61, 78, 79, 63, 62, 80, 62, 79, 80, 64, 63, 81, 63, 80, 81, 65, 64, 82, 64, 81, 82, 66, 65, 83, 65, 82, 83, 67, 66, 84, 66, 83, 84, 69, 68, 86, 68, 85, 86, 70, 69, 87, 69, 86, 87, 71, 70, 88, 70, 87, 88, 72, 71, 89, 71, 88, 89, 73, 72, 90, 72, 89, 90, 74, 73, 91, 73, 90, 91, 75, 74, 92, 74, 91, 92, 76, 75, 93, 75, 92, 93, 77, 76, 94, 76, 93, 94, 78, 77, 95, 77, 94, 95, 79, 78, 96, 78, 95, 96, 80, 79, 97, 79, 96, 97, 81, 80, 98, 80, 97, 98, 82, 81, 99, 81, 98, 99, 83, 82, 100, 82, 99, 100, 84, 83, 101, 83, 100, 101, 86, 85, 103, 85, 102, 103, 87, 86, 104, 86, 103, 104, 88, 87, 105, 87, 104, 105, 89, 88, 106, 88, 105, 106, 90, 89, 107, 89, 106, 107, 91, 90, 108, 90, 107, 108, 92, 91, 109, 91, 108, 109, 93, 92, 110, 92, 109, 110, 94, 93, 111, 93, 110, 111, 95, 94, 112, 94, 111, 112, 96, 95, 113, 95, 112, 113, 97, 96, 114, 96, 113, 114, 98, 97, 115, 97, 114, 115, 99, 98, 116, 98, 115, 116, 100, 99, 117, 99, 116, 117, 101, 100, 118, 100, 117, 118, 103, 102, 120, 102, 119, 120, 104, 103, 121, 103, 120, 121, 105, 104, 122, 104, 121, 122, 106, 105, 123, 105, 122, 123, 107, 106, 124, 106, 123, 124, 108, 107, 125, 107, 124, 125, 109, 108, 126, 108, 125, 126, 110, 109, 127, 109, 126, 127, 111, 110, 128, 110, 127, 128, 112, 111, 129, 111, 128, 129, 113, 112, 130, 112, 129, 130, 114, 113, 131, 113, 130, 131, 115, 114, 132, 114, 131, 132, 116, 115, 133, 115, 132, 133, 117, 116, 134, 116, 133, 134, 118, 117, 135, 117, 134, 135, 120, 119, 137, 121, 120, 138, 122, 121, 139, 123, 122, 140, 124, 123, 141, 125, 124, 142, 126, 125, 143, 127, 126, 144, 128, 127, 145, 129, 128, 146, 130, 129, 147, 131, 130, 148, 132, 131, 149, 133, 132, 150, 134, 133, 151, 135, 134, 152], s = 153) : this.voxType === "cylinder" ? (n = [0, 17, 1, 17, 18, 1, 1, 18, 2, 18, 19, 2, 2, 19, 3, 19, 20, 3, 3, 20, 4, 20, 21, 4, 4, 21, 5, 21, 22, 5, 5, 22, 6, 22, 23, 6, 6, 23, 7, 23, 24, 7, 7, 24, 8, 24, 25, 8, 8, 25, 9, 25, 26, 9, 9, 26, 10, 26, 27, 10, 10, 27, 11, 27, 28, 11, 11, 28, 12, 28, 29, 12, 12, 29, 13, 29, 30, 13, 13, 30, 14, 30, 31, 14, 14, 31, 15, 31, 32, 15, 15, 32, 16, 32, 33, 16, 50, 51, 34, 51, 52, 35, 52, 53, 36, 53, 54, 37, 54, 55, 38, 55, 56, 39, 56, 57, 40, 57, 58, 41, 58, 59, 42, 59, 60, 43, 60, 61, 44, 61, 62, 45, 62, 63, 46, 63, 64, 47, 64, 65, 48, 65, 66, 49, 84, 83, 67, 85, 84, 68, 86, 85, 69, 87, 86, 70, 88, 87, 71, 89, 88, 72, 90, 89, 73, 91, 90, 74, 92, 91, 75, 93, 92, 76, 94, 93, 77, 95, 94, 78, 96, 95, 79, 97, 96, 80, 98, 97, 81, 99, 98, 82], s = 100) : this.voxType === "tetrahedron" ? (n = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], s = 12) : this.voxType === "octahedron" ? (n = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], s = 24) : this.voxType === "lego" && (n = [0, 2, 1, 2, 3, 1, 4, 6, 5, 6, 7, 5, 8, 10, 9, 10, 11, 9, 12, 14, 13, 14, 15, 13, 16, 18, 17, 18, 19, 17, 20, 22, 21, 22, 23, 21, 24, 41, 25, 41, 42, 25, 25, 42, 26, 42, 43, 26, 26, 43, 27, 43, 44, 27, 27, 44, 28, 44, 45, 28, 28, 45, 29, 45, 46, 29, 29, 46, 30, 46, 47, 30, 30, 47, 31, 47, 48, 31, 31, 48, 32, 48, 49, 32, 32, 49, 33, 49, 50, 33, 33, 50, 34, 50, 51, 34, 34, 51, 35, 51, 52, 35, 35, 52, 36, 52, 53, 36, 36, 53, 37, 53, 54, 37, 37, 54, 38, 54, 55, 38, 38, 55, 39, 55, 56, 39, 39, 56, 40, 56, 57, 40, 74, 75, 58, 75, 76, 59, 76, 77, 60, 77, 78, 61, 78, 79, 62, 79, 80, 63, 80, 81, 64, 81, 82, 65, 82, 83, 66, 83, 84, 67, 84, 85, 68, 85, 86, 69, 86, 87, 70, 87, 88, 71, 88, 89, 72, 89, 90, 73, 108, 107, 91, 109, 108, 92, 110, 109, 93, 111, 110, 94, 112, 111, 95, 113, 112, 96, 114, 113, 97, 115, 114, 98, 116, 115, 99, 117, 116, 100, 118, 117, 101, 119, 118, 102, 120, 119, 103, 121, 120, 104, 122, 121, 105, 123, 122, 106], s = 124), o.setIndex(new h0(new Uint8Array(n), 1));
    const r = new Uint32Array(s);
    for (let u = 0; u < s; u++) r[u] = u;
    o.setAttribute("aVoxVertex", new h0(r, 1));
    const a = new Uint32Array(e * this.voxDim);
    if (o.setAttribute("aVoxData", new Q(a, this.voxDim)), this.voxType === "cube") {
      const u = new Uint32Array(this.__findAllVoxNB());
      o.setAttribute("aVoxNB", new Q(u, 1));
    }
    let i = 0;
    const c = this.voxDim, h = 16776961, l = 0;
    for (const [u, p] of t.entries())
      a[i] = u, a[i + 1] = p.vc, c >= 3 && (a[i + 2] = p.vs === void 0 ? h : p.vs), c >= 4 && (a[i + 3] = p.vr === void 0 ? l : p.vr), p.vi = i, i += c;
    return o;
  }
  __createVoxMeshMaterial(t) {
    var a;
    const e = this.voxType.toUpperCase() + "_VOXEL", o = (a = this.atlas) != null && a.uvScale ? this.atlas.uvScale : [1, 1 / 3], s = this.voxDim;
    s >= 3 && (t = { ...t, transparent: !0 });
    const n = new M0(t), r = {
      uvScale: { value: new p0(o[0], o[1]) }
    };
    return n.onBeforeCompile = (i) => {
      i.uniforms = { ...i.uniforms, ...r }, i.vertexShader = `
                #define ${e}
                #define VOX_DIM ${s}
                #if defined( CUBE_VOXEL )
                    int VERTICES[72] = int[72]( 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1 );
                    int NORMALS[18] = int[18]( -1, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1, 0, 0, 0, -1, 0, 0, 1 );
                    int UVS[48] = int[48]( 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1 );
                    int UVROWS[6] = int[6]( 0, 0, 1, 2, 0, 0 );
                    uniform vec2 uvScale;
                    attribute uint aVoxNB; // existence of neighbor voxels
                #elif defined( BOX_VOXEL )
                    int VERTICES[72] = int[72]( 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0 );
                    int NORMALS[72] = int[72]( 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1 );
                    int UVS[48] = int[48]( 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0 );
                #elif defined( SPHERE8_VOXEL )
                    float VERTICES[135] = float[135]( 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.1464466154575348, 0.8535533845424652, 0.5, 0.25, 0.8535533845424652, 0.75, 0.5, 0.8535533845424652, 0.8535533845424652, 0.75, 0.8535533845424652, 0.75, 0.8535533845424652, 0.8535533845424652, 0.5, 0.75, 0.8535533845424652, 0.25, 0.5000000000000001, 0.8535533845424652, 0.1464466154575348, 0.25, 0.8535533845424652, 0.25, 0.1464466154575348, 0.8535533845424652, 0.4999999999999999, 0.0, 0.5, 0.5, 0.1464466154575348, 0.5, 0.8535533845424652, 0.5, 0.5, 1.0, 0.8535533845424652, 0.5, 0.8535533845424652, 1.0, 0.5, 0.5, 0.8535533845424652, 0.5, 0.1464466154575348, 0.5, 0.5, 0.0, 0.1464466154575348, 0.5, 0.1464466154575348, 0.0, 0.5, 0.5, 0.1464466154575348, 0.1464466154575348, 0.5, 0.25, 0.1464466154575348, 0.75, 0.5, 0.1464466154575348, 0.8535533845424652, 0.75, 0.1464466154575348, 0.75, 0.8535533845424652, 0.1464466154575348, 0.5, 0.75, 0.1464466154575348, 0.25, 0.5, 0.1464466154575348, 0.1464466154575348, 0.25, 0.1464466154575348, 0.25, 0.1464466154575348, 0.1464466154575348, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5 );
                    float NORMALS[135] = float[135]( 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, -0.7071067690849304, 0.7071067690849304, 0.0, -0.5, 0.7071067690849304, 0.5, 0.0, 0.7071067690849304, 0.7071067690849304, 0.5, 0.7071067690849304, 0.5, 0.7071067690849304, 0.7071067690849304, 0.0, 0.5, 0.7071067690849304, -0.5, 0.0, 0.7071067690849304, -0.7071067690849304, -0.5, 0.7071067690849304, -0.5, -0.7071067690849304, 0.7071067690849304, 0.0, -1.0, 0.0, 0.0, -0.7071067690849304, 0.0, 0.7071067690849304, 0.0, 0.0, 1.0, 0.7071067690849304, 0.0, 0.7071067690849304, 1.0, 0.0, 0.0, 0.7071067690849304, 0.0, -0.7071067690849304, 0.0, 0.0, -1.0, -0.7071067690849304, 0.0, -0.7071067690849304, -1.0, 0.0, 0.0, -0.7071067690849304, -0.7071067690849304, 0.0, -0.5, -0.7071067690849304, 0.5, 0.0, -0.7071067690849304, 0.7071067690849304, 0.5, -0.7071067690849304, 0.5, 0.7071067690849304, -0.7071067690849304, 0.0, 0.5, -0.7071067690849304, -0.5, 0.0, -0.7071067690849304, -0.7071067690849304, -0.5, -0.7071067690849304, -0.5, -0.7071067690849304, -0.7071067690849304, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0 );
                    float UVS[90] = float[90]( 0.0625, 1.0, 0.1875, 1.0, 0.3125, 1.0, 0.4375, 1.0, 0.5625, 1.0, 0.6875, 1.0, 0.8125, 1.0, 0.9375, 1.0, 1.0625, 1.0, 0.0, 0.75, 0.125, 0.75, 0.25, 0.75, 0.375, 0.75, 0.5, 0.75, 0.625, 0.75, 0.75, 0.75, 0.875, 0.75, 1.0, 0.75, 0.0, 0.5, 0.125, 0.5, 0.25, 0.5, 0.375, 0.5, 0.5, 0.5, 0.625, 0.5, 0.75, 0.5, 0.875, 0.5, 1.0, 0.5, 0.0, 0.25, 0.125, 0.25, 0.25, 0.25, 0.375, 0.25, 0.5, 0.25, 0.625, 0.25, 0.75, 0.25, 0.875, 0.25, 1.0, 0.25, -0.0625, 0.0, 0.0625, 0.0, 0.1875, 0.0, 0.3125, 0.0, 0.4375, 0.0, 0.5625, 0.0, 0.6875, 0.0, 0.8125, 0.0, 0.9375, 0.0 );
                #elif defined( SPHERE_VOXEL )
                    float VERTICES[459] = float[459]( 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.30865828692913055, 0.9619397521018982, 0.5, 0.3232233077287674, 0.9619397521018982, 0.5732233077287674, 0.36470097303390503, 0.9619397521018982, 0.635299026966095, 0.4267766922712326, 0.9619397521018982, 0.6767766922712326, 0.5, 0.9619397521018982, 0.6913417130708694, 0.5732233077287674, 0.9619397521018982, 0.6767766922712326, 0.635299026966095, 0.9619397521018982, 0.635299026966095, 0.6767766922712326, 0.9619397521018982, 0.5732233077287674, 0.6913417130708694, 0.9619397521018982, 0.5, 0.6767766922712326, 0.9619397521018982, 0.4267766922712326, 0.635299026966095, 0.9619397521018982, 0.36470097303390503, 0.5732233077287674, 0.9619397521018982, 0.3232233077287674, 0.5, 0.9619397521018982, 0.30865828692913055, 0.4267766922712326, 0.9619397521018982, 0.3232233077287674, 0.36470097303390503, 0.9619397521018982, 0.36470097303390503, 0.3232233077287674, 0.9619397521018982, 0.4267766922712326, 0.30865828692913055, 0.9619397521018982, 0.5, 0.1464466154575348, 0.8535533845424652, 0.5, 0.1733592450618744, 0.8535533845424652, 0.635299026966095, 0.25, 0.8535533845424652, 0.75, 0.36470097303390503, 0.8535533845424652, 0.8266407549381256, 0.5, 0.8535533845424652, 0.8535533845424652, 0.635299026966095, 0.8535533845424652, 0.8266407549381256, 0.75, 0.8535533845424652, 0.75, 0.8266407549381256, 0.8535533845424652, 0.635299026966095, 0.8535533845424652, 0.8535533845424652, 0.5, 0.8266407549381256, 0.8535533845424652, 0.36470097303390503, 0.75, 0.8535533845424652, 0.25, 0.635299026966095, 0.8535533845424652, 0.1733592450618744, 0.5, 0.8535533845424652, 0.1464466154575348, 0.36470097303390503, 0.8535533845424652, 0.1733592450618744, 0.25, 0.8535533845424652, 0.25, 0.1733592450618744, 0.8535533845424652, 0.36470097303390503, 0.1464466154575348, 0.8535533845424652, 0.4999999999999999, 0.03806024789810181, 0.6913417130708694, 0.5, 0.0732232928276062, 0.6913417130708694, 0.6767766922712326, 0.1733592450618744, 0.6913417130708694, 0.8266407549381256, 0.3232233077287674, 0.6913417130708694, 0.9267767071723938, 0.5, 0.6913417130708694, 0.9619397521018982, 0.6767766922712326, 0.6913417130708694, 0.9267767071723938, 0.8266407549381256, 0.6913417130708694, 0.8266407549381256, 0.9267767071723938, 0.6913417130708694, 0.6767766922712326, 0.9619397521018982, 0.6913417130708694, 0.5, 0.9267767071723938, 0.6913417130708694, 0.3232233077287674, 0.8266407549381256, 0.6913417130708694, 0.1733592450618744, 0.6767766922712326, 0.6913417130708694, 0.0732232928276062, 0.5, 0.6913417130708694, 0.03806024789810181, 0.3232233077287674, 0.6913417130708694, 0.0732232928276062, 0.1733592450618744, 0.6913417130708694, 0.1733592450618744, 0.0732232928276062, 0.6913417130708694, 0.3232233077287674, 0.03806024789810181, 0.6913417130708694, 0.4999999999999999, 0.0, 0.5, 0.5, 0.03806024789810181, 0.5, 0.6913417130708694, 0.1464466154575348, 0.5, 0.8535533845424652, 0.30865828692913055, 0.5, 0.9619397521018982, 0.5, 0.5, 1.0, 0.6913417130708694, 0.5, 0.9619397521018982, 0.8535533845424652, 0.5, 0.8535533845424652, 0.9619397521018982, 0.5, 0.6913417130708694, 1.0, 0.5, 0.5, 0.9619397521018982, 0.5, 0.30865828692913055, 0.8535533845424652, 0.5, 0.1464466154575348, 0.6913417130708694, 0.5, 0.03806024789810181, 0.5, 0.5, 0.0, 0.30865828692913055, 0.5, 0.03806024789810181, 0.1464466154575348, 0.5, 0.1464466154575348, 0.03806024789810181, 0.5, 0.30865828692913055, 0.0, 0.5, 0.4999999999999999, 0.03806024789810181, 0.30865828692913055, 0.5, 0.0732232928276062, 0.30865828692913055, 0.6767766922712326, 0.1733592450618744, 0.30865828692913055, 0.8266407549381256, 0.3232233077287674, 0.30865828692913055, 0.9267767071723938, 0.5, 0.30865828692913055, 0.9619397521018982, 0.6767766922712326, 0.30865828692913055, 0.9267767071723938, 0.8266407549381256, 0.30865828692913055, 0.8266407549381256, 0.9267767071723938, 0.30865828692913055, 0.6767766922712326, 0.9619397521018982, 0.30865828692913055, 0.5, 0.9267767071723938, 0.30865828692913055, 0.3232233077287674, 0.8266407549381256, 0.30865828692913055, 0.1733592450618744, 0.6767766922712326, 0.30865828692913055, 0.0732232928276062, 0.5, 0.30865828692913055, 0.03806024789810181, 0.3232233077287674, 0.30865828692913055, 0.0732232928276062, 0.1733592450618744, 0.30865828692913055, 0.1733592450618744, 0.0732232928276062, 0.30865828692913055, 0.3232233077287674, 0.03806024789810181, 0.30865828692913055, 0.4999999999999999, 0.1464466154575348, 0.1464466154575348, 0.5, 0.1733592450618744, 0.1464466154575348, 0.635299026966095, 0.25, 0.1464466154575348, 0.75, 0.36470097303390503, 0.1464466154575348, 0.8266407549381256, 0.5, 0.1464466154575348, 0.8535533845424652, 0.635299026966095, 0.1464466154575348, 0.8266407549381256, 0.75, 0.1464466154575348, 0.75, 0.8266407549381256, 0.1464466154575348, 0.635299026966095, 0.8535533845424652, 0.1464466154575348, 0.5, 0.8266407549381256, 0.1464466154575348, 0.36470097303390503, 0.75, 0.1464466154575348, 0.25, 0.635299026966095, 0.1464466154575348, 0.1733592450618744, 0.5, 0.1464466154575348, 0.1464466154575348, 0.36470097303390503, 0.1464466154575348, 0.1733592450618744, 0.25, 0.1464466154575348, 0.25, 0.1733592450618744, 0.1464466154575348, 0.36470097303390503, 0.1464466154575348, 0.1464466154575348, 0.4999999999999999, 0.30865828692913055, 0.03806024789810181, 0.5, 0.3232233077287674, 0.03806024789810181, 0.5732233077287674, 0.36470097303390503, 0.03806024789810181, 0.635299026966095, 0.4267766922712326, 0.03806024789810181, 0.6767766922712326, 0.5, 0.03806024789810181, 0.6913417130708694, 0.5732233077287674, 0.03806024789810181, 0.6767766922712326, 0.635299026966095, 0.03806024789810181, 0.635299026966095, 0.6767766922712326, 0.03806024789810181, 0.5732233077287674, 0.6913417130708694, 0.03806024789810181, 0.5, 0.6767766922712326, 0.03806024789810181, 0.4267766922712326, 0.635299026966095, 0.03806024789810181, 0.36470097303390503, 0.5732233077287674, 0.03806024789810181, 0.3232233077287674, 0.5, 0.03806024789810181, 0.30865828692913055, 0.4267766922712326, 0.03806024789810181, 0.3232233077287674, 0.36470097303390503, 0.03806024789810181, 0.36470097303390503, 0.3232233077287674, 0.03806024789810181, 0.4267766922712326, 0.30865828692913055, 0.03806024789810181, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5 );
                    float NORMALS[459] = float[459]( 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, -0.3826834261417389, 0.9238795042037964, 0.0, -0.3535533845424652, 0.9238795042037964, 0.1464466154575348, -0.27059805393218994, 0.9238795042037964, 0.27059805393218994, -0.1464466154575348, 0.9238795042037964, 0.3535533845424652, 0.0, 0.9238795042037964, 0.3826834261417389, 0.1464466154575348, 0.9238795042037964, 0.3535533845424652, 0.27059805393218994, 0.9238795042037964, 0.27059805393218994, 0.3535533845424652, 0.9238795042037964, 0.1464466154575348, 0.3826834261417389, 0.9238795042037964, 0.0, 0.3535533845424652, 0.9238795042037964, -0.1464466154575348, 0.27059805393218994, 0.9238795042037964, -0.27059805393218994, 0.1464466154575348, 0.9238795042037964, -0.3535533845424652,0.0, 0.9238795042037964, -0.3826834261417389, -0.1464466154575348, 0.9238795042037964, -0.3535533845424652, -0.27059805393218994, 0.9238795042037964, -0.27059805393218994, -0.3535533845424652, 0.9238795042037964, -0.1464466154575348, -0.3826834261417389, 0.9238795042037964, 0.0, -0.7071067690849304, 0.7071067690849304, 0.0, -0.6532815098762512, 0.7071067690849304, 0.27059805393218994, -0.5, 0.7071067690849304, 0.5, -0.27059805393218994, 0.7071067690849304, 0.6532815098762512, 0.0, 0.7071067690849304, 0.7071067690849304, 0.27059805393218994, 0.7071067690849304, 0.6532815098762512, 0.5, 0.7071067690849304, 0.5, 0.6532815098762512, 0.7071067690849304, 0.27059805393218994, 0.7071067690849304, 0.7071067690849304,0.0, 0.6532815098762512, 0.7071067690849304, -0.27059805393218994, 0.5, 0.7071067690849304, -0.5, 0.27059805393218994, 0.7071067690849304, -0.6532815098762512, 0.0, 0.7071067690849304, -0.7071067690849304, -0.27059805393218994, 0.7071067690849304, -0.6532815098762512, -0.5, 0.7071067690849304, -0.5, -0.6532815098762512, 0.7071067690849304, -0.27059805393218994, -0.7071067690849304, 0.7071067690849304, 0.0, -0.9238795042037964, 0.3826834261417389, 0.0, -0.8535534143447876, 0.3826834261417389, 0.3535533845424652, -0.6532815098762512, 0.3826834261417389, 0.6532815098762512, -0.3535533845424652, 0.3826834261417389, 0.8535534143447876, 0.0, 0.3826834261417389, 0.9238795042037964, 0.3535533845424652, 0.3826834261417389, 0.8535534143447876, 0.6532815098762512, 0.3826834261417389, 0.6532815098762512, 0.8535534143447876, 0.3826834261417389, 0.3535533845424652, 0.9238795042037964, 0.3826834261417389, 0.0, 0.8535534143447876, 0.3826834261417389, -0.3535533845424652, 0.6532815098762512, 0.3826834261417389, -0.6532815098762512, 0.3535533845424652, 0.3826834261417389, -0.8535534143447876, 0.0, 0.3826834261417389, -0.9238795042037964, -0.3535533845424652, 0.3826834261417389, -0.8535534143447876, -0.6532815098762512, 0.3826834261417389, -0.6532815098762512, -0.8535534143447876, 0.3826834261417389, -0.3535533845424652, -0.9238795042037964, 0.3826834261417389, 0.0, -1.0,0.0, 0.0, -0.9238795042037964,0.0, 0.3826834261417389, -0.7071067690849304,0.0, 0.7071067690849304, -0.3826834261417389,0.0, 0.9238795042037964, 0.0,0.0, 1.0, 0.3826834261417389,0.0, 0.9238795042037964, 0.7071067690849304,0.0, 0.7071067690849304, 0.9238795042037964,0.0, 0.3826834261417389, 1.0,0.0, 0.0, 0.9238795042037964,0.0, -0.3826834261417389, 0.7071067690849304,0.0, -0.7071067690849304, 0.3826834261417389,0.0, -0.9238795042037964, 0.0,0.0, -1.0, -0.3826834261417389,0.0, -0.9238795042037964, -0.7071067690849304,0.0, -0.7071067690849304, -0.9238795042037964,0.0, -0.3826834261417389, -1.0,0.0, 0.0, -0.9238795042037964, -0.3826834261417389, 0.0, -0.8535534143447876, -0.3826834261417389, 0.3535533845424652, -0.6532815098762512, -0.3826834261417389, 0.6532815098762512, -0.3535533845424652, -0.3826834261417389, 0.8535534143447876, 0.0, -0.3826834261417389, 0.9238795042037964, 0.3535533845424652, -0.3826834261417389, 0.8535534143447876, 0.6532815098762512, -0.3826834261417389, 0.6532815098762512, 0.8535534143447876, -0.3826834261417389, 0.3535533845424652, 0.9238795042037964, -0.3826834261417389, 0.0, 0.8535534143447876, -0.3826834261417389, -0.3535533845424652, 0.6532815098762512, -0.3826834261417389, -0.6532815098762512, 0.3535533845424652, -0.3826834261417389, -0.8535534143447876, 0.0, -0.3826834261417389, -0.9238795042037964, -0.3535533845424652, -0.3826834261417389, -0.8535534143447876, -0.6532815098762512, -0.3826834261417389, -0.6532815098762512, -0.8535534143447876, -0.3826834261417389, -0.3535533845424652, -0.9238795042037964, -0.3826834261417389, 0.0, -0.7071067690849304, -0.7071067690849304, 0.0, -0.6532815098762512, -0.7071067690849304, 0.27059805393218994, -0.5, -0.7071067690849304, 0.5, -0.27059805393218994, -0.7071067690849304, 0.6532815098762512, 0.0, -0.7071067690849304, 0.7071067690849304, 0.27059805393218994, -0.7071067690849304, 0.6532815098762512, 0.5, -0.7071067690849304, 0.5, 0.6532815098762512, -0.7071067690849304, 0.27059805393218994, 0.7071067690849304, -0.7071067690849304,0.0, 0.6532815098762512, -0.7071067690849304, -0.27059805393218994, 0.5, -0.7071067690849304, -0.5, 0.27059805393218994, -0.7071067690849304, -0.6532815098762512, 0.0, -0.7071067690849304, -0.7071067690849304, -0.27059805393218994, -0.7071067690849304, -0.6532815098762512, -0.5, -0.7071067690849304, -0.5, -0.6532815098762512, -0.7071067690849304, -0.27059805393218994, -0.7071067690849304, -0.7071067690849304, 0.0, -0.3826834261417389, -0.9238795042037964, 0.0, -0.3535533845424652, -0.9238795042037964, 0.1464466154575348, -0.27059805393218994, -0.9238795042037964, 0.27059805393218994, -0.1464466154575348, -0.9238795042037964, 0.3535533845424652, 0.0, -0.9238795042037964, 0.3826834261417389, 0.1464466154575348, -0.9238795042037964, 0.3535533845424652, 0.27059805393218994, -0.9238795042037964, 0.27059805393218994, 0.3535533845424652, -0.9238795042037964, 0.1464466154575348, 0.3826834261417389, -0.9238795042037964, 0.0, 0.3535533845424652, -0.9238795042037964, -0.1464466154575348, 0.27059805393218994, -0.9238795042037964, -0.27059805393218994, 0.1464466154575348, -0.9238795042037964, -0.3535533845424652,0.0, -0.9238795042037964, -0.3826834261417389, -0.1464466154575348, -0.9238795042037964, -0.3535533845424652, -0.27059805393218994, -0.9238795042037964, -0.27059805393218994, -0.3535533845424652, -0.9238795042037964, -0.1464466154575348, -0.3826834261417389, -0.9238795042037964, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0,0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0,0.0, -1.0,0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0,0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0 );
                    float UVS[306] = float[306]( 0.03125, 1.0, 0.09375, 1.0, 0.15625, 1.0, 0.21875, 1.0, 0.28125, 1.0, 0.34375, 1.0, 0.40625, 1.0, 0.46875, 1.0, 0.53125, 1.0, 0.59375, 1.0, 0.65625, 1.0, 0.71875, 1.0, 0.78125, 1.0, 0.84375, 1.0, 0.90625, 1.0, 0.96875, 1.0, 1.03125, 1.0, 0.0, 0.875, 0.0625, 0.875, 0.125, 0.875, 0.1875, 0.875, 0.25, 0.875, 0.3125, 0.875, 0.375, 0.875, 0.4375, 0.875, 0.5, 0.875, 0.5625, 0.875, 0.625, 0.875, 0.6875, 0.875, 0.75, 0.875, 0.8125, 0.875, 0.875, 0.875, 0.9375, 0.875, 1.0, 0.875, 0.0, 0.75, 0.0625, 0.75, 0.125, 0.75, 0.1875, 0.75, 0.25, 0.75, 0.3125, 0.75, 0.375, 0.75, 0.4375, 0.75, 0.5, 0.75, 0.5625, 0.75, 0.625, 0.75, 0.6875, 0.75, 0.75, 0.75, 0.8125, 0.75, 0.875, 0.75, 0.9375, 0.75, 1.0, 0.75, 0.0, 0.625, 0.0625, 0.625, 0.125, 0.625, 0.1875, 0.625, 0.25, 0.625, 0.3125, 0.625, 0.375, 0.625, 0.4375, 0.625, 0.5, 0.625, 0.5625, 0.625, 0.625, 0.625, 0.6875, 0.625, 0.75, 0.625, 0.8125, 0.625, 0.875, 0.625, 0.9375, 0.625, 1.0, 0.625, 0.0, 0.5, 0.0625, 0.5, 0.125, 0.5, 0.1875, 0.5, 0.25, 0.5, 0.3125, 0.5, 0.375, 0.5, 0.4375, 0.5, 0.5, 0.5, 0.5625, 0.5, 0.625, 0.5, 0.6875, 0.5, 0.75, 0.5, 0.8125, 0.5, 0.875, 0.5, 0.9375, 0.5, 1.0, 0.5, 0.0, 0.375, 0.0625, 0.375, 0.125, 0.375, 0.1875, 0.375, 0.25, 0.375, 0.3125, 0.375, 0.375, 0.375, 0.4375, 0.375, 0.5, 0.375, 0.5625, 0.375, 0.625, 0.375, 0.6875, 0.375, 0.75, 0.375, 0.8125, 0.375, 0.875, 0.375, 0.9375, 0.375, 1.0, 0.375, 0.0, 0.25, 0.0625, 0.25, 0.125, 0.25, 0.1875, 0.25, 0.25, 0.25, 0.3125, 0.25, 0.375, 0.25, 0.4375, 0.25, 0.5, 0.25, 0.5625, 0.25, 0.625, 0.25, 0.6875, 0.25, 0.75, 0.25, 0.8125, 0.25, 0.875, 0.25, 0.9375, 0.25, 1.0, 0.25, 0.0, 0.125, 0.0625, 0.125, 0.125, 0.125, 0.1875, 0.125, 0.25, 0.125, 0.3125, 0.125, 0.375, 0.125, 0.4375, 0.125, 0.5, 0.125, 0.5625, 0.125, 0.625, 0.125, 0.6875, 0.125, 0.75, 0.125, 0.8125, 0.125, 0.875, 0.125, 0.9375, 0.125, 1.0, 0.125, 0.03125, 0.0, 0.03125, 0.0, 0.09375, 0.0, 0.15625, 0.0, 0.21875, 0.0, 0.28125, 0.0, 0.34375, 0.0, 0.40625, 0.0, 0.46875, 0.0, 0.53125, 0.0, 0.59375, 0.0, 0.65625, 0.0, 0.71875, 0.0, 0.78125, 0.0, 0.84375, 0.0, 0.90625, 0.0, 0.96875, 0.0 );
                #elif defined( CYLINDER_VOXEL )
                    float VERTICES[300] = float[300]( 0.5, 1.0, 1.0, 0.6913417130708694, 1.0, 0.9619397521018982, 0.8535533845424652, 1.0, 0.8535533845424652, 0.9619397521018982, 1.0, 0.6913417130708694, 1.0, 1.0, 0.5, 0.9619397521018982, 1.0, 0.30865828692913055, 0.8535533845424652, 1.0, 0.1464466154575348, 0.6913417130708694, 1.0, 0.03806024789810181, 0.5, 1.0, 0.0, 0.30865828692913055, 1.0, 0.03806024789810181, 0.1464466154575348, 1.0, 0.1464466154575348, 0.03806024789810181, 1.0, 0.30865828692913055, 0.0, 1.0, 0.5, 0.03806024789810181, 1.0, 0.6913417130708694, 0.1464466154575348, 1.0, 0.8535533845424652, 0.30865828692913055, 1.0, 0.9619397521018982, 0.5, 1.0, 1.0, 0.5, 0.0, 1.0, 0.6913417130708694, 0.0, 0.9619397521018982, 0.8535533845424652, 0.0, 0.8535533845424652, 0.9619397521018982, 0.0, 0.6913417130708694, 1.0, 0.0, 0.5, 0.9619397521018982, 0.0, 0.30865828692913055, 0.8535533845424652, 0.0, 0.1464466154575348, 0.6913417130708694, 0.0, 0.03806024789810181, 0.5, 0.0, 0.0, 0.30865828692913055, 0.0, 0.03806024789810181, 0.1464466154575348, 0.0, 0.1464466154575348, 0.03806024789810181, 0.0, 0.30865828692913055, 0.0, 0.0, 0.5, 0.03806024789810181, 0.0, 0.6913417130708694, 0.1464466154575348, 0.0, 0.8535533845424652, 0.30865828692913055, 0.0, 0.9619397521018982, 0.5, 0.0, 1.0, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 0.5, 0.5, 1.0, 1.0, 0.6913417130708694, 1.0, 0.9619397521018982, 0.8535533845424652, 1.0, 0.8535533845424652, 0.9619397521018982, 1.0, 0.6913417130708694, 1.0, 1.0, 0.5, 0.9619397521018982, 1.0, 0.30865828692913055, 0.8535533845424652, 1.0, 0.1464466154575348, 0.6913417130708694, 1.0, 0.03806024789810181, 0.5, 1.0, 0.0, 0.30865828692913055, 1.0, 0.03806024789810181, 0.1464466154575348, 1.0, 0.1464466154575348, 0.03806024789810181, 1.0, 0.30865828692913055, 0.0, 1.0, 0.5, 0.03806024789810181, 1.0, 0.6913417130708694, 0.1464466154575348, 1.0, 0.8535533845424652, 0.30865828692913055, 1.0, 0.9619397521018982, 0.5, 1.0, 1.0, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 0.5, 0.5, 0.0, 1.0, 0.6913417130708694, 0.0, 0.9619397521018982, 0.8535533845424652, 0.0, 0.8535533845424652, 0.9619397521018982, 0.0, 0.6913417130708694, 1.0, 0.0, 0.5, 0.9619397521018982, 0.0, 0.30865828692913055, 0.8535533845424652, 0.0, 0.1464466154575348, 0.6913417130708694, 0.0, 0.03806024789810181, 0.5, 0.0, 0.0, 0.30865828692913055, 0.0, 0.03806024789810181, 0.1464466154575348, 0.0, 0.1464466154575348, 0.03806024789810181, 0.0, 0.30865828692913055, 0.0, 0.0, 0.5, 0.03806024789810181, 0.0, 0.6913417130708694, 0.1464466154575348, 0.0, 0.8535533845424652, 0.30865828692913055, 0.0, 0.9619397521018982, 0.5, 0.0, 1.0 );
                    float NORMALS[300] = float[300]( 0.0, 0.0, 1.0, 0.3826834261417389, 0.0, 0.9238795042037964, 0.7071067690849304, 0.0, 0.7071067690849304, 0.9238795042037964, 0.0, 0.3826834261417389, 1.0, 0.0, 0.0, 0.9238795042037964, 0.0, -0.3826834261417389, 0.7071067690849304, 0.0, -0.7071067690849304, 0.3826834261417389, 0.0, -0.9238795042037964, 0.0, 0.0, -1.0, -0.3826834261417389, 0.0, -0.9238795042037964, -0.7071067690849304, 0.0, -0.7071067690849304, -0.9238795042037964, 0.0, -0.3826834261417389, -1.0, 0.0, 0.0, -0.9238795042037964, 0.0, 0.3826834261417389, -0.7071067690849304, 0.0, 0.7071067690849304, -0.3826834261417389, 0.0, 0.9238795042037964, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.3826834261417389, 0.0, 0.9238795042037964, 0.7071067690849304, 0.0, 0.7071067690849304, 0.9238795042037964, 0.0, 0.3826834261417389, 1.0, 0.0, 0.0, 0.9238795042037964, 0.0, -0.3826834261417389, 0.7071067690849304, 0.0, -0.7071067690849304, 0.3826834261417389, 0.0, -0.9238795042037964, 0.0, 0.0, -1.0, -0.3826834261417389, 0.0, -0.9238795042037964, -0.7071067690849304, 0.0, -0.7071067690849304, -0.9238795042037964, 0.0, -0.3826834261417389, -1.0, 0.0, 0.0, -0.9238795042037964, 0.0, 0.3826834261417389, -0.7071067690849304, 0.0, 0.7071067690849304, -0.3826834261417389, 0.0, 0.9238795042037964, 0.0, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0 );
                    float UVS[200] = float[200]( 0.0, 1.0, 0.0625, 1.0, 0.125, 1.0, 0.1875, 1.0, 0.25, 1.0, 0.3125, 1.0, 0.375, 1.0, 0.4375, 1.0, 0.5, 1.0, 0.5625, 1.0, 0.625, 1.0, 0.6875, 1.0, 0.75, 1.0, 0.8125, 1.0, 0.875, 1.0, 0.9375, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0625, 0.0, 0.125, 0.0, 0.1875, 0.0, 0.25, 0.0, 0.3125, 0.0, 0.375, 0.0, 0.4375, 0.0, 0.5, 0.0, 0.5625, 0.0, 0.625, 0.0, 0.6875, 0.0, 0.75, 0.0, 0.8125, 0.0, 0.875, 0.0, 0.9375, 0.0, 1.0, 0.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 0.5, 0.9619397521018982, 0.6913416981697083, 0.8535534143447876, 0.8535534143447876, 0.6913416981697083, 0.9619397521018982, 0.5, 1.0, 0.30865827202796936, 0.9619397521018982, 0.1464466154575348, 0.8535534143447876, 0.03806023299694061, 0.6913416981697083, 0.0, 0.5, 0.03806023299694061, 0.30865827202796936, 0.1464466154575348, 0.1464466154575348, 0.30865827202796936, 0.03806023299694061, 0.5, 0.0, 0.6913416981697083, 0.03806023299694061, 0.8535534143447876, 0.1464466154575348, 0.9619397521018982, 0.30865827202796936, 1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 0.5, 0.9619397521018982, 0.30865827202796936, 0.8535534143447876, 0.1464466154575348, 0.6913416981697083, 0.03806023299694061, 0.5, 0.0, 0.30865827202796936, 0.03806023299694061, 0.1464466154575348, 0.1464466154575348, 0.03806023299694061, 0.30865827202796936, 0.0, 0.5, 0.03806023299694061, 0.6913416981697083, 0.1464466154575348, 0.8535534143447876, 0.30865827202796936, 0.9619397521018982, 0.5, 1.0, 0.6913416981697083, 0.9619397521018982, 0.8535534143447876, 0.8535534143447876, 0.9619397521018982, 0.6913416981697083, 1.0, 0.5 );
                #elif defined( TETRAHEDRON_VOXEL )
                    float VERTICES[36] = float[36]( 0.21132487058639526, 0.21132487058639526, 0.7886751294136047, 0.7886751294136047, 0.7886751294136047, 0.7886751294136047, 0.21132487058639526, 0.7886751294136047, 0.21132487058639526, 0.7886751294136047, 0.21132487058639526, 0.21132487058639526, 0.21132487058639526, 0.7886751294136047, 0.21132487058639526, 0.7886751294136047, 0.7886751294136047, 0.7886751294136047, 0.7886751294136047, 0.21132487058639526, 0.21132487058639526, 0.7886751294136047, 0.7886751294136047, 0.7886751294136047, 0.21132487058639526, 0.21132487058639526, 0.7886751294136047, 0.7886751294136047, 0.21132487058639526, 0.21132487058639526, 0.21132487058639526, 0.21132487058639526, 0.7886751294136047, 0.21132487058639526, 0.7886751294136047, 0.21132487058639526 );
                    float NORMALS[36] = float[36]( -0.5773502588272095, 0.5773502588272095, 0.5773502588272095, -0.5773502588272095, 0.5773502588272095, 0.5773502588272095, -0.5773502588272095, 0.5773502588272095, 0.5773502588272095, 0.5773502588272095, 0.5773502588272095, -0.5773502588272095, 0.5773502588272095, 0.5773502588272095, -0.5773502588272095, 0.5773502588272095, 0.5773502588272095, -0.5773502588272095, 0.5773502588272095, -0.5773502588272095, 0.5773502588272095, 0.5773502588272095, -0.5773502588272095, 0.5773502588272095, 0.5773502588272095, -0.5773502588272095, 0.5773502588272095, -0.5773502588272095, -0.5773502588272095, -0.5773502588272095, -0.5773502588272095, -0.5773502588272095, -0.5773502588272095, -0.5773502588272095, -0.5773502588272095, -0.5773502588272095 );
                    float UVS[24] = float[24]( 0.625, 0.30408671498298645, 0.875, 0.6959132552146912, 0.375, 0.6959132552146912, 0.125, 0.30408671498298645, 0.375, 0.6959132552146912, 0.875, 0.6959132552146912, 0.125, 0.30408671498298645, 0.875, 0.6959132552146912, 0.625, 0.30408671498298645, 0.125, 0.30408671498298645, 0.625, 0.30408671498298645, 0.375, 0.6959132552146912 );
                #elif defined( OCTAHEDRON_VOXEL )
                    float VERTICES[72] = float[72]( 0.5, 1.0, 0.5, 0.5, 0.5, 1.0, 1.0, 0.5, 0.5, 0.5, 0.5, 1.0, 0.5, 0.0, 0.5, 1.0, 0.5, 0.5, 0.5, 0.0, 0.5, 0.5, 0.5, 0.0, 1.0, 0.5, 0.5, 0.5, 0.5, 0.0, 0.5, 1.0, 0.5, 1.0, 0.5, 0.5, 0.5, 1.0, 0.5, 0.5, 0.5, 0.0, 0.0, 0.5, 0.5, 0.5, 0.5, 0.0, 0.5, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0, 0.0, 0.5, 0.5, 0.5, 0.5, 1.0, 0.5, 1.0, 0.5, 0.0, 0.5, 0.5 );
                    float NORMALS[72] = float[72]( 0.5773502588272095, 0.5773502588272095, 0.5773502588272095, 0.5773502588272095, 0.5773502588272095, 0.5773502588272095, 0.5773502588272095, 0.5773502588272095, 0.5773502588272095, 0.5773502588272095, -0.5773502588272095, 0.5773502588272095, 0.5773502588272095, -0.5773502588272095, 0.5773502588272095, 0.5773502588272095, -0.5773502588272095, 0.5773502588272095, 0.5773502588272095, -0.5773502588272095, -0.5773502588272095, 0.5773502588272095, -0.5773502588272095, -0.5773502588272095, 0.5773502588272095, -0.5773502588272095, -0.5773502588272095, 0.5773502588272095, 0.5773502588272095, -0.5773502588272095, 0.5773502588272095, 0.5773502588272095, -0.5773502588272095, 0.5773502588272095, 0.5773502588272095, -0.5773502588272095, -0.5773502588272095, 0.5773502588272095, -0.5773502588272095, -0.5773502588272095, 0.5773502588272095, -0.5773502588272095, -0.5773502588272095, 0.5773502588272095, -0.5773502588272095, -0.5773502588272095, -0.5773502588272095, -0.5773502588272095, -0.5773502588272095, -0.5773502588272095, -0.5773502588272095, -0.5773502588272095, -0.5773502588272095, -0.5773502588272095, -0.5773502588272095, -0.5773502588272095, 0.5773502588272095, -0.5773502588272095, -0.5773502588272095, 0.5773502588272095, -0.5773502588272095, -0.5773502588272095, 0.5773502588272095, -0.5773502588272095, 0.5773502588272095, 0.5773502588272095, -0.5773502588272095, 0.5773502588272095, 0.5773502588272095, -0.5773502588272095, 0.5773502588272095, 0.5773502588272095 );
                    float UVS[48] = float[48]( 0.875, 1.0, 0.75, 0.5, 1.0, 0.5, 0.75, 0.5, 0.875, 0.0, 1.0, 0.5, 0.125, 0.0, 0.25, 0.5, 0.0, 0.5, 0.25, 0.5, 0.125, 1.0, 0.0, 0.5, 0.375, 1.0, 0.25, 0.5, 0.5, 0.5, 0.25, 0.5, 0.375, 0.0, 0.5, 0.5, 0.625, 0.0, 0.75, 0.5, 0.5, 0.5, 0.75, 0.5, 0.625, 1.0, 0.5, 0.5 );
                #elif defined( LEGO_VOXEL )
                    float VERTICES[372] = float[372]( 1.5, 1.5, 1.5, 1.5, 1.5, 0.5, 1.5, 0.5, 1.5, 1.5, 0.5, 0.5, 0.5, 1.5, 0.5, 0.5, 1.5, 1.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.5, 0.5, 1.5, 0.5, 1.5, 1.5, 0.5, 0.5, 1.5, 1.5, 1.5, 1.5, 1.5, 0.5, 0.5, 1.5, 1.5, 0.5, 1.5, 0.5, 0.5, 0.5, 1.5, 0.5, 0.5, 0.5, 1.5, 1.5, 1.5, 1.5, 1.5, 0.5, 0.5, 1.5, 1.5, 0.5, 1.5, 1.5, 1.5, 0.5, 0.5, 1.5, 0.5, 1.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 1.7000000476837158, 1.350000023841858, 1.1339392066001892, 1.7000000476837158, 1.3233578205108643, 1.2474873661994934, 1.7000000476837158, 1.2474873661994934, 1.3233578205108643, 1.7000000476837158, 1.1339392066001892, 1.350000023841858, 1.7000000476837158, 1.0, 1.3233578205108643, 1.7000000476837158, 0.8660607933998108, 1.2474873661994934, 1.7000000476837158, 0.7525126338005066, 1.1339392066001892, 1.7000000476837158, 0.6766421496868134, 1.0, 1.7000000476837158, 0.6500000059604645, 0.8660607933998108, 1.7000000476837158, 0.6766421496868134, 0.7525126338005066, 1.7000000476837158, 0.7525126338005066, 0.6766421496868134, 1.7000000476837158, 0.8660607933998108, 0.6500000059604645, 1.7000000476837158, 1.0, 0.6766421496868134, 1.7000000476837158, 1.1339392066001892, 0.7525126338005066, 1.7000000476837158, 1.2474873661994934, 0.8660607933998108, 1.7000000476837158, 1.3233578205108643, 1.0, 1.7000000476837158, 1.350000023841858, 1.0, 1.300000011920929, 1.350000023841858, 1.1339392066001892, 1.300000011920929, 1.3233578205108643, 1.2474873661994934, 1.300000011920929, 1.2474873661994934, 1.3233578205108643, 1.300000011920929, 1.1339392066001892, 1.350000023841858, 1.300000011920929, 1.0, 1.3233578205108643, 1.300000011920929, 0.8660607933998108, 1.2474873661994934, 1.300000011920929, 0.7525126338005066, 1.1339392066001892, 1.300000011920929, 0.6766421496868134, 1.0, 1.300000011920929, 0.6500000059604645, 0.8660607933998108, 1.300000011920929, 0.6766421496868134, 0.7525126338005066, 1.300000011920929, 0.7525126338005066, 0.6766421496868134, 1.300000011920929, 0.8660607933998108, 0.6500000059604645, 1.300000011920929, 1.0, 0.6766421496868134, 1.300000011920929, 1.1339392066001892, 0.7525126338005066, 1.300000011920929, 1.2474873661994934, 0.8660607933998108, 1.300000011920929, 1.3233578205108643, 1.0, 1.300000011920929, 1.350000023841858, 1.0, 1.7000000476837158, 1.0, 1.0, 1.7000000476837158, 1.0, 1.0, 1.7000000476837158, 1.0, 1.0, 1.7000000476837158, 1.0, 1.0, 1.7000000476837158, 1.0, 1.0, 1.7000000476837158, 1.0, 1.0, 1.7000000476837158, 1.0, 1.0, 1.7000000476837158, 1.0, 1.0, 1.7000000476837158, 1.0, 1.0, 1.7000000476837158, 1.0, 1.0, 1.7000000476837158, 1.0, 1.0, 1.7000000476837158, 1.0, 1.0, 1.7000000476837158, 1.0, 1.0, 1.7000000476837158, 1.0, 1.0, 1.7000000476837158, 1.0, 1.0, 1.7000000476837158, 1.0, 1.0, 1.7000000476837158, 1.350000023841858, 1.1339392066001892, 1.7000000476837158, 1.3233578205108643, 1.2474873661994934, 1.7000000476837158, 1.2474873661994934, 1.3233578205108643, 1.7000000476837158, 1.1339392066001892, 1.350000023841858, 1.7000000476837158, 1.0, 1.3233578205108643, 1.7000000476837158, 0.8660607933998108, 1.2474873661994934, 1.7000000476837158, 0.7525126338005066, 1.1339392066001892, 1.7000000476837158, 0.6766421496868134, 1.0, 1.7000000476837158, 0.6500000059604645, 0.8660607933998108, 1.7000000476837158, 0.6766421496868134, 0.7525126338005066, 1.7000000476837158, 0.7525126338005066, 0.6766421496868134, 1.7000000476837158, 0.8660607933998108, 0.6500000059604645, 1.7000000476837158, 1.0, 0.6766421496868134, 1.7000000476837158, 1.1339392066001892, 0.7525126338005066, 1.7000000476837158, 1.2474873661994934, 0.8660607933998108, 1.7000000476837158, 1.3233578205108643, 1.0, 1.7000000476837158, 1.350000023841858, 1.0, 1.300000011920929, 1.0, 1.0, 1.300000011920929, 1.0, 1.0, 1.300000011920929, 1.0, 1.0, 1.300000011920929, 1.0, 1.0, 1.300000011920929, 1.0, 1.0, 1.300000011920929, 1.0, 1.0, 1.300000011920929, 1.0, 1.0, 1.300000011920929, 1.0, 1.0, 1.300000011920929, 1.0, 1.0, 1.300000011920929, 1.0, 1.0, 1.300000011920929, 1.0, 1.0, 1.300000011920929, 1.0, 1.0, 1.300000011920929, 1.0, 1.0, 1.300000011920929, 1.0, 1.0, 1.300000011920929, 1.0, 1.0, 1.300000011920929, 1.0, 1.0, 1.300000011920929, 1.350000023841858, 1.1339392066001892, 1.300000011920929, 1.3233578205108643, 1.2474873661994934, 1.300000011920929, 1.2474873661994934, 1.3233578205108643, 1.300000011920929, 1.1339392066001892, 1.350000023841858, 1.300000011920929, 1.0, 1.3233578205108643, 1.300000011920929, 0.8660607933998108, 1.2474873661994934, 1.300000011920929, 0.7525126338005066, 1.1339392066001892, 1.300000011920929, 0.6766421496868134, 1.0, 1.300000011920929, 0.6500000059604645, 0.8660607933998108, 1.300000011920929, 0.6766421496868134, 0.7525126338005066, 1.300000011920929, 0.7525126338005066, 0.6766421496868134, 1.300000011920929, 0.8660607933998108, 0.6500000059604645, 1.300000011920929, 1.0, 0.6766421496868134, 1.300000011920929, 1.1339392066001892, 0.7525126338005066, 1.300000011920929, 1.2474873661994934, 0.8660607933998108, 1.300000011920929, 1.3233578205108643, 1.0, 1.300000011920929, 1.350000023841858 );
                    float NORMALS[372] = float[372]( 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, 1.0, 0.3826834261417389, 0.0, 0.9238795042037964, 0.7071067690849304, 0.0, 0.7071067690849304, 0.9238795042037964, 0.0, 0.3826834261417389, 1.0, 0.0, 6.123234262925839e-17, 0.9238795042037964, 0.0, -0.3826834261417389, 0.7071067690849304, 0.0, -0.7071067690849304, 0.3826834261417389, 0.0, -0.9238795042037964, 1.2246468525851679e-16, 0.0, -1.0, -0.3826834261417389, 0.0, -0.9238795042037964, -0.7071067690849304, 0.0, -0.7071067690849304, -0.9238795042037964, 0.0, -0.3826834261417389, -1.0, 0.0, -1.8369701465288538e-16, -0.9238795042037964, 0.0, 0.3826834261417389, -0.7071067690849304, 0.0, 0.7071067690849304, -0.3826834261417389, 0.0, 0.9238795042037964, -2.4492937051703357e-16, 0.0, 1.0, 0.0, 0.0, 1.0, 0.3826834261417389, 0.0, 0.9238795042037964, 0.7071067690849304, 0.0, 0.7071067690849304, 0.9238795042037964, 0.0, 0.3826834261417389, 1.0, 0.0, 6.123234262925839e-17, 0.9238795042037964, 0.0, -0.3826834261417389, 0.7071067690849304, 0.0, -0.7071067690849304, 0.3826834261417389, 0.0, -0.9238795042037964, 1.2246468525851679e-16, 0.0, -1.0, -0.3826834261417389, 0.0, -0.9238795042037964, -0.7071067690849304, 0.0, -0.7071067690849304, -0.9238795042037964, 0.0, -0.3826834261417389, -1.0, 0.0, -1.8369701465288538e-16, -0.9238795042037964, 0.0, 0.3826834261417389, -0.7071067690849304, 0.0, 0.7071067690849304, -0.3826834261417389, 0.0, 0.9238795042037964, -2.4492937051703357e-16, 0.0, 1.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0 );
                    float UVS[248] = float[248]( 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0625, 1.0, 0.125, 1.0, 0.1875, 1.0, 0.25, 1.0, 0.3125, 1.0, 0.375, 1.0, 0.4375, 1.0, 0.5, 1.0, 0.5625, 1.0, 0.625, 1.0, 0.6875, 1.0, 0.75, 1.0, 0.8125, 1.0, 0.875, 1.0, 0.9375, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0625, 0.0, 0.125, 0.0, 0.1875, 0.0, 0.25, 0.0, 0.3125, 0.0, 0.375, 0.0, 0.4375, 0.0, 0.5, 0.0, 0.5625, 0.0, 0.625, 0.0, 0.6875, 0.0, 0.75, 0.0, 0.8125, 0.0, 0.875, 0.0, 0.9375, 0.0, 1.0, 0.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 0.5, 0.9619397521018982, 0.6913416981697083, 0.8535534143447876, 0.8535534143447876, 0.6913416981697083, 0.9619397521018982, 0.5, 1.0, 0.30865827202796936, 0.9619397521018982, 0.1464466154575348, 0.8535534143447876, 0.03806023299694061, 0.6913416981697083, 0.0, 0.5, 0.03806023299694061, 0.30865827202796936, 0.1464466154575348, 0.1464466154575348, 0.30865827202796936, 0.03806023299694061, 0.5, 0.0, 0.6913416981697083, 0.03806023299694061, 0.8535534143447876, 0.1464466154575348, 0.9619397521018982, 0.30865827202796936, 1.0, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 1.0, 0.5, 0.9619397521018982, 0.30865827202796936, 0.8535534143447876, 0.1464466154575348, 0.6913416981697083, 0.03806023299694061, 0.5, 0.0, 0.30865827202796936, 0.03806023299694061, 0.1464466154575348, 0.1464466154575348, 0.03806023299694061, 0.30865827202796936, 0.0, 0.5, 0.03806023299694061, 0.6913416981697083, 0.1464466154575348, 0.8535534143447876, 0.30865827202796936, 0.9619397521018982, 0.5, 1.0, 0.6913416981697083, 0.9619397521018982, 0.8535534143447876, 0.8535534143447876, 0.9619397521018982, 0.6913416981697083, 1.0, 0.5 );
                #endif
                attribute uint aVoxVertex; // index of voxel vertex
                attribute uvec4 aVoxData;
                // aVoxData.x = voxPos( null, pz, py, px )
                // aVoxData.y = voxCol( tileId, hexCol(r,g,b) )
                // aVoxData.z = voxSize( null, life, opacity, size )
                // aVoxData.w = voxRot( null, rz, ry, rx )

                varying vec3 vVoxColor; // xyz = ( r, g, b )
                varying vec4 vVoxSize;  // xyzw = ( size, opacity, life, null )
                varying vec4 vVoxRot;   // xyzw = ( rotx, roty, rotz, null )

                varying vec2 vUv;

                int V_NB_MASK[32] = int[32](
                    0x01, 0x02, 0x04, 0x08, 
                    0x10, 0x20, 0x40, 0x80, 
                    0x100, 0x200, 0x400, 0x800, 
                    0x1000, 0x2000, 0x4000, 0x8000, 
                    0x10000, 0x20000, 0x40000, 0x80000, 
                    0x100000, 0x200000, 0x400000, 0x800000, 
                    0x1000000, 0x2000000, 0x4000000, 0x8000000, 
                    0x10000000, 0x20000000, 0x40000000, 0x80000000 );

                int V_EXIST_IDX[72] = int[72]( 10,16,20,10,14,18,11,16,24,11,14,22,13,17,25,13,15,23,12,17,21,12,15,19,8,15,23,8,14,22,6,15,19,6,14,18,9,16,24,9,17,25,7,16,20,7,17,21,6,12,19,6,10,18,7,12,21,7,10,20,8,11,22,8,13,23,9,11,24,9,13,25 );

                vec4 uint_to_vec4( uint vp )
                {
                    uint u256 = uint( 256 );
                    float w = float( ( vp / u256 / u256 / u256 ) % u256 );
                    float z = float( ( vp / u256 / u256 ) % u256 );
                    float y = float( ( vp / u256 ) % u256 );
                    float x = float( ( vp ) % u256 );
                    return vec4( x, y, z, w );
                }

                vec3 hexToRGB( uint hex )
                {
                    uint u256 = uint( 256 );
                    float r = float( ( hex / u256 / u256 ) % u256 );
                    float g = float( ( hex / u256        ) % u256 );
                    float b = float( ( hex               ) % u256 );
                    return vec3( r / 255.0, g / 255.0, b / 255.0 );
                }

                float ambientOcc( int vertex, int neighbors )
                {
                    float ao = 0.0;
                    int q = int( vertex / 4 );
                    int e = vertex * 3;
                    int a = V_EXIST_IDX[ e ];
                    int b = V_EXIST_IDX[ e + 1 ];
                    int c = V_EXIST_IDX[ e + 2 ];
                    int qExist = int(bool( neighbors & V_NB_MASK[ q ] ));
                    int aExist = int(bool( neighbors & V_NB_MASK[ a ] ));
                    int bExist = int(bool( neighbors & V_NB_MASK[ b ] ));
                    int cExist = int(bool( neighbors & V_NB_MASK[ c ] ));
                    ao += float( (1 - qExist) * (aExist + bExist + cExist) );
                    return (3.0 - ao) / 3.0;
                }

                mat3 rotX( float angle )
                {
                    float s = sin(angle);
                    float c = cos(angle);
                    return mat3(
                        1.0, 0.0, 0.0,
                        0.0,   c,   s,
                        0.0,  -s,   c
                    );
                }
                mat3 rotY( float angle )
                {
                    float s = sin(angle);
                    float c = cos(angle);
                    return mat3(
                          c, 0.0,  -s,
                        0.0, 1.0, 0.0,
                          s, 0.0,   c
                    );
                }
                mat3 rotZ( float angle )
                {
                    float s = sin(angle);
                    float c = cos(angle);
                    return mat3(
                          c,   s, 0.0,
                         -s,   c, 0.0,
                        0.0, 0.0, 1.0
                    );
                }

                ${i.vertexShader.replace(
        "#include <uv_vertex>",
        `
                    #include <uv_vertex>
                    #ifdef CUBE_VOXEL
                        int face = int(aVoxVertex) / 4; // face = Left, Right, ..., Front
                    #endif
                    #ifdef CUBE_VOXEL
                        int fi = int( face );
                        int ui = int(aVoxVertex) * 2;
                        uint u256 = uint( 256 );
                        int uvCol = int( ( aVoxData.y / u256 / u256 / u256 ) % u256 );
                        vec2 uv = vec2( float( uvCol + UVS[ ui ] ) * uvScale.x, 1.0 - float( UVROWS[ fi ] + 1 - UVS[ ui + 1 ] ) * uvScale.y );
                    #else
                        int uvi = int(aVoxVertex) * 2;
                        vec2 uv = vec2( UVS[ uvi ], UVS[ uvi + 1 ] );
                    #endif

                    vUv = uv;

                    #ifdef USE_MAP
                        vMapUv = uv;
                    #endif

                    #ifdef USE_NORMALMAP
                        vNormalMapUv = uv;
                    #endif

                    #ifdef USE_AOMAP
                        vAoMapUv = uv;
                    #endif
                    `
      )}
            `, i.vertexShader = i.vertexShader.replace(
        "#include <color_vertex>",
        `
                #include <color_vertex>
                vVoxColor = hexToRGB( aVoxData.y );

                #ifdef CUBE_VOXEL
                    vVoxColor *= ambientOcc( int(aVoxVertex), int(aVoxNB) );
                #endif
                `
      ), i.vertexShader = i.vertexShader.replace(
        "#include <beginnormal_vertex>",
        `
                #ifdef CUBE_VOXEL
                    int ni = face * 3;
                    vec3 objectNormal = vec3( NORMALS[ ni ], NORMALS[ ni + 1 ], NORMALS[ ni + 2 ] );
                #else
                    int vi = int(aVoxVertex) * 3;
                    vec3 objectNormal = vec3( NORMALS[ vi ], NORMALS[ vi + 1 ], NORMALS[ vi + 2 ] );
                #endif
                `
      ), i.vertexShader = i.vertexShader.replace(
        "#include <begin_vertex>",
        `
                // voxel position
                vec4 xyzw = uint_to_vec4( aVoxData.x );
                vec3 vpos = vec3( xyzw );

                // voxel vertex
                #ifdef CUBE_VOXEL
                    int vi = int(aVoxVertex) * 3;
                #endif

                float vsize = 1.0;
                if( VOX_DIM >= 3 )
                {
                    vVoxSize = uint_to_vec4( aVoxData.z );
                    vsize = vVoxSize.x;
                }

                vec3 vtxPos = vec3( VERTICES[ vi ], VERTICES[ vi + 1 ], VERTICES[ vi + 2 ] );

                if( VOX_DIM >= 4 )
                {
                    vVoxRot = uint_to_vec4( aVoxData.w );

                    float thetaX = vVoxRot.x * PI2/256.0; // rx (in radian)
                    float thetaY = vVoxRot.y * PI2/256.0; // rx (in radian)
                    float thetaZ = vVoxRot.z * PI2/256.0; // rx (in radian)

                    vtxPos -= vec3(0.5);
                    vtxPos = rotX( thetaX ) * vtxPos;
                    vtxPos = rotY( thetaY ) * vtxPos;
                    vtxPos = rotZ( thetaZ ) * vtxPos;
                    vtxPos += vec3(0.5);
                }

                #if defined( SPHERE8_VOXEL ) || defined( SPHERE_VOXEL ) || defined( TETRAHEDRON_VOXEL ) || defined( OCTAHEDRON_VOXEL )
                    vpos = vpos + vec3( vsize * 1.5 ) * vtxPos;
                #else
                    vpos = vpos + vec3( vsize ) * vtxPos;
                #endif

                vec3 transformed = vpos;
                `
      ), i.fragmentShader = `
                #define ${e}
                #define VOX_DIM ${s}
                varying vec3 vVoxColor; // xyz = ( r, g, b )
                varying vec4 vVoxSize;  // xyzw = ( size, opacity, life, null )
                varying vec4 vVoxRot;   // xyzw = ( rotx, roty, rotz, null )

                ${i.fragmentShader.replace(
        "vec4 diffuseColor = vec4( diffuse, opacity );",
        `
                    vec4 diffuseColor = vec4( vVoxColor, opacity );
                    if( VOX_DIM >= 3 )
                    {
                        if( vVoxSize.z < 0.5 ) discard;         // life
                        diffuseColor.a *= (vVoxSize.y / 255.0); // opacity
                    }
                    `
      )}
            `;
    }, n;
  }
  __updateVoxMeshGeometry() {
    this.geometry && this.geometry.dispose(), this.geometry = this.__createVoxMeshGeometry(this.voxMap);
  }
  __updateVoxMeshMaterial(t = {}) {
    var s, n;
    this.material && this.material.dispose();
    const e = (s = this.atlas) != null && s.diffuseMap ? this.atlas.diffuseMap : null, o = (n = this.atlas) != null && n.normalMap ? this.atlas.normalMap : null;
    this.material = this.__createVoxMeshMaterial({
      map: e,
      normalMap: o,
      ...t
    });
  }
  __updateFromVoxMap() {
    this.__updateVoxMeshGeometry();
  }
  createVoxelMesh() {
    this.__prepareVoxelMesh(), this.__updateVoxMeshGeometry(), this.__updateVoxMeshMaterial(), this.frustumCulled = !1;
  }
  // utils
  getVoxelCount() {
    return this.voxMap.size;
  }
  rgbToHex(t, e, o) {
    return t * 255 << 16 ^ e * 255 << 8 ^ o * 255;
  }
  hexToRGB(t) {
    return [(t >> 16 & 255) / 255, (t >> 8 & 255) / 255, (t & 255) / 255];
  }
  world_to_local(t) {
    return t.applyMatrix4(x0.copy(this.matrixWorld).invert()), t;
  }
  local_to_world(t) {
    return t.applyMatrix4(this.matrixWorld), t;
  }
  // debug
  __getVoxelCenter(t, e = "world") {
    const o = this.vp_to_xyz(t);
    return o[0] += 0.5, o[1] += 0.5, o[2] += 0.5, I.fromArray(o), e === "world" && this.local_to_world(I), I;
  }
  __drawXVoxel(t, e) {
    H.copy(t), this.isShiftDown ? H.addScaledVector(e, -0.5) : H.addScaledVector(e, 0.5);
    const o = this.getVoxelPos(H);
    this.__drawVoxel(o);
  }
  __drawVoxel(t) {
    if (Y === null) {
      const o = new S0(1.02, 1.02, 1.02), s = new E0({ color: 16711680, opacity: 0.5, transparent: !0 });
      Y = new c0(o, s), this.threefy.scene.add(Y);
    }
    const e = this.__getVoxelCenter(t);
    Y.position.copy(e);
  }
  __drawVoxelBoxes(t) {
    if (G === null) {
      G = new L0();
      for (let e = 0; e < 12; e++)
        G.add(new R0(new f0(), 16711680));
      this.threefy.scene.add(G);
    }
    for (let e = 0; e < 12; e++)
      G.children[e].visible = !1;
    t.forEach((e, o) => {
      const s = G.children[o];
      if (e) {
        const n = this.__getVoxelCenter(e);
        $.setFromMatrixScale(this.matrixWorld);
        const r = $.multiply({ x: 1.02, y: 1.02, z: 1.02 });
        s.visible = !0, s.box.setFromCenterAndSize(n, r);
      }
    });
  }
  __drawArrowHelper(t, e) {
    P === null && (P = new w0(), P.setLength(1), P.setColor(16711680), this.threefy.scene.add(P)), P.position.copy(t), P.setDirection(e);
  }
  __updateDrawNeighbors() {
    const t = this.threefy, e = t.camera, o = t.raycaster, s = t.mouseMovePosition, n = [];
    if (o.setFromCamera(s, e), this.raycast(o, n), n.length > 0) {
      const { point: r, normal: a, color: i } = n[0];
      H.copy(r), H.addScaledVector(a, -0.5);
      const c = this.getVoxelPos(H);
      let h;
      h = this.findFaceNeighbors(c), this.__drawVoxelBoxes(h);
    }
  }
  __deleteVoxel(t, e) {
    X.copy(t), X.addScaledVector(e, -0.5);
    const o = this.getVoxelPos(X);
    this.deleteVoxels([o]);
  }
  __addVoxel(t, e) {
    X.copy(t), X.addScaledVector(e, -0.5);
    const o = this.getVoxelPos(X), s = this.voxMap.get(o);
    X.addScaledVector(e, 1);
    const n = this.getVoxelPos(X), r = this.geometry.attributes.aVoxData.array.length;
    this.addVoxels([[n, { ...s, vi: r }]]);
  }
  // typed array
  addVoxData(t, e) {
    const o = this.geometry.attributes.aVoxData.array, s = this.voxDim, n = o.length / s, r = new Uint32Array((n + 1) * s);
    r.set(o, 0);
    const a = n * s;
    r[a] = t, r[a + 1] = e.vc, s >= 3 && (r[a + 2] = e.vs), s >= 4 && (r[a + 3] = e.vr), this.geometry.setAttribute("aVoxData", new Q(r, s)), this.geometry.attributes.aVoxData.needsUpdate = !0, this.voxMap.set(t, { ...e, vi: a });
  }
  __concatTypedArrays(t, ...e) {
    const o = e.reduce((n, r) => n + r.length, 0), s = new t(o);
    return e.reduce((n, r) => (s.set(r, n), n + r.length), 0), s;
  }
  __deleteTypedElement(t, e, o) {
    const s = [];
    s.push(e.subarray(0, o[0]));
    for (let r = 0; r < o.length - 1; r++)
      s.push(e.subarray(o[r] + 1, o[r + 1]));
    const n = o.length - 1;
    return s.push(e.subarray(o[n] + 1)), this.__concatTypedArrays(t, ...s);
  }
  // intersection
  intersectRay(t, e) {
    const o = I.copy(t), s = $.copy(e);
    this.world_to_local(o), this.world_to_local(s);
    let n = s.x - o.x, r = s.y - o.y, a = s.z - o.z;
    const i = Math.sqrt(n ** 2 + r ** 2 + a ** 2);
    n /= i, r /= i, a /= i;
    let c = 0, h = Math.floor(o.x), l = Math.floor(o.y), u = Math.floor(o.z);
    const p = n > 0 ? 1 : n == 0 ? 0 : -1, d = r > 0 ? 1 : r == 0 ? 0 : -1, R = a > 0 ? 1 : a == 0 ? 0 : -1, y = Math.abs(1 / n), M = Math.abs(1 / r), x = Math.abs(1 / a), v = p >= 0 ? h + 1 - o.x : o.x - h, V = d >= 0 ? l + 1 - o.y : o.y - l, O = R >= 0 ? u + 1 - o.z : o.z - u;
    let b = y < 1 / 0 ? y * v : 1 / 0, S = M < 1 / 0 ? M * V : 1 / 0, _ = x < 1 / 0 ? x * O : 1 / 0, g = -1;
    for (; c <= i; ) {
      const L = this.getVoxel(h, l, u);
      if (L) {
        o.x += c * n, o.y += c * r, o.z += c * a, this.local_to_world(o), s.x = g === 0 ? -p : 0, s.y = g === 1 ? -d : 0, s.z = g === 2 ? -R : 0;
        const m = I0.set(s.x, s.y, s.z, 0).applyMatrix4(this.matrixWorld);
        return s.set(m.x, m.y, m.z), {
          position: o,
          // _v1
          normal: s,
          // _v2
          color: L
          // voxCol (= tileId ^ hexCol)
        };
      }
      b < S ? b < _ ? (h += p, c = b, b += y, g = 0) : (u += R, c = _, _ += x, g = 2) : S < _ ? (l += d, c = S, S += M, g = 1) : (u += R, c = _, _ += x, g = 2);
    }
    return null;
  }
  raycast(t, e) {
    if (!this.voxMap || this.voxMap.size === 0) return;
    const o = t.ray, s = o.origin, n = o.at(t.camera.far, $), r = this.intersectRay(s, n);
    if (r) {
      const a = r.position, i = r.normal, c = r.color, l = o.origin.distanceTo(a);
      e.push({
        distance: l,
        point: a,
        // _v1
        normal: i,
        // _v2
        color: c,
        object: this
      });
    }
  }
  // boundingBox
  getBoundingBox(t = "local") {
    if (t === "local") {
      let e = 1 / 0, o = 1 / 0, s = 1 / 0, n = -1 / 0, r = -1 / 0, a = -1 / 0;
      const i = this.voxMap;
      for (const h of i.keys()) {
        const [l, u, p] = C.get_xyz(h);
        e = Math.min(e, l), n = Math.max(n, l), o = Math.min(o, u), r = Math.max(r, u), s = Math.min(s, p), a = Math.max(a, p);
      }
      const c = new f0();
      return c.min.set(e, o, s), c.max.set(n, r, a), c;
    } else {
      const e = this.getBoundingBox("local");
      return this.updateMatrix(), e.applyMatrix4(this.matrix), e;
    }
  }
  // boundingSphere
  getBoundingSphere(t = "local") {
    if (t === "local") {
      const e = this.getBoundingBox("local"), o = new C0(), s = o.center;
      e.getCenter(s);
      let n = 0;
      const r = this.voxMap;
      for (const a of r.keys()) {
        const [i, c, h] = C.get_xyz(a);
        let l = 0;
        l += (i - s.x) ** 2, l += (c - s.y) ** 2, l += (h - s.z) ** 2, n = Math.max(n, l);
      }
      return o.radius = Math.sqrt(n), o;
    } else {
      const e = this.getBoundingSphere("local");
      return this.updateMatrix(), e.applyMatrix4(this.matrix), e;
    }
  }
  // transform
  center() {
    const t = this.getBoundingBox("local");
    t.min.multiply(this.scale), t.max.multiply(this.scale), this.position.x = -(t.min.x + t.max.x) / 2, this.position.y = -(t.min.y + t.max.y) / 2, this.position.z = -(t.min.z + t.max.z) / 2, this.updateMatrix();
  }
  rotate(t, e) {
    t === "x" ? (I.set(1, 0, 0), t = I) : t === "y" ? (I.set(0, 1, 0), t = I) : t === "z" && (I.set(0, 0, 1), t = I), this.applyMatrix4(x0.makeRotationAxis(t, e));
  }
  scaleDown(t) {
    const e = [], o = [], s = this.voxMap;
    for (const [n, { vc: r }] of s.entries()) {
      const [a, i, c] = C.get_xyz(n);
      e.push(a * t, i * t, c * t);
      const h = C.get_col(r);
      o.push(h);
    }
    this.initVoxMap(), this.createFromPositions(e, o), this.center();
  }
  simplify(t = 0.5) {
    this.scaleDown(t), this.scale.setScalar(1 / t), this.center();
  }
  // copy
  copy(t, e) {
    return super.copy(t, e), t.options && (this.options = { ...t.options }), this.voxMap = new Map(t.voxMap), this.voxDim = t.voxDim, this.voxType = t.voxType, t.atlas && (this.atlas = { ...t.atlas }), this;
  }
  // create
  createFromPositions(t, e = null, o = null, s = null, n = null, r = null) {
    for (let i = 0, c = 0, h = t.length; c < h; c += 3, i++) {
      const l = t[c], u = t[c + 1], p = t[c + 2], d = e ? e[i] : 16777215, R = o ? o[i] : 0;
      this.setVoxel(l, u, p, [d, R]);
    }
    this.atlas || (this.atlas = {}), s && (this.atlas.uvScale = [...s]);
    const a = new l0();
    if (n != null && n.diffuseMap && (this.atlas.diffuseMap = typeof n.diffuseMap == "string" ? a.load(n.diffuseMap) : n.diffuseMap), n != null && n.normalMap && (this.atlas.normalMap = typeof n.normalMap == "string" ? a.load(n.normalMap) : n.normalMap), this.createVoxelMesh(), r) {
      const i = this.material;
      for (let c in r)
        i[c] !== void 0 && (i[c] = r[c]);
    }
  }
  // save & load
  async loadVOX(t) {
    let e = (c) => {
      const h = c[Symbol.iterator](), l = () => h.next().value, u = () => ({ x: l(), y: l(), z: l(), color: l() }), p = () => ({ r: l(), g: l(), b: l(), a: l() }), d = () => l() + (l() << 8) + (l() << 16) + (l() << 24), R = (_, g) => [...Array(_)].map(g), y = (_) => R(_, () => String.fromCharCode(l())).join(""), M = () => new Map(R(d(), (_) => [y(d()), y(d())])), x = () => ({ id: d(), attrs: M() }), v = () => R(d(), M)[0], V = () => ({ child: d(), layer: d(d()), transfo: v() }), O = () => R(d(), x)[0], b = {
        MAIN: () => {
        },
        // only children chunks
        PACK: () => ({ nbModels: d() }),
        SIZE: () => ({ x: d(), y: d(), z: d() }),
        XYZI: () => ({ voxels: R(d(), u) }),
        RGBA: () => ({ palette: [{}, ...R(256, p)] }),
        // color 0 reserved ?
        // extensions
        nTRN: () => ({ ...x(), ...V() }),
        nGRP: () => ({ ...x(), ids: R(d(), d) }),
        nSHP: () => ({ ...x(), model: O() }),
        MATL: () => ({ ...x() }),
        LAYR: () => ({ ...x(), reserved: d() }),
        rOBJ: () => ({ attrs: M() })
        // not documented: background, grid, fog, etc.
      }, S = () => {
        const [_, g, L] = [y(4), d(), d()], m = 12 + g + L, E = b[_], w = E ? E() : { data: y(g) }, T = function* (z) {
          for (; z > 0; ) {
            const { chunk: A, length: N } = S();
            yield A, z -= N;
          }
        }, U = { type: _, ...w };
        return L && (U.children = [...T(L)]), { chunk: U, length: m };
      };
      return y(4), d(), S().chunk;
    }, o = (c) => {
      const { children: h } = e(c), l = h.reduce((z, A) => {
        const { type: N } = A;
        return (z[N] = z[N] || []).push(A), z;
      }, {}), { x: u, y: p, z: d } = h[0], R = { x: u, y: p, z: d }, { palette: y } = l.RGBA[0], M = /* @__PURE__ */ new Map(), x = /* @__PURE__ */ new Map(), v = /* @__PURE__ */ new Map();
      let V = 0;
      const O = (z, A, N) => (1 << 24 | N << 16 | A << 8 | z).toString(16).slice(1);
      y.slice(0).forEach(({ r: z, g: A, b: N, a: k }, W) => {
        const K = O(z, A, N);
        x.has(K) || (x.set(K, [z, A, N]), M.set(++V, K)), v.set(W, V);
      });
      const b = /* @__PURE__ */ new Map(), S = (z) => {
        const A = [], N = /* @__PURE__ */ new Map();
        return z.forEach(({ x: k, y: W, z: K, color: _0 }) => {
          const q = v.get(_0), J = M.get(q);
          N.set(q, J), b.set(J, x.get(J)), A.push([k, W, K, q]);
        }), { size: R, voxels: A, colorMap: N };
      }, _ = new Map(
        l.XYZI.map(({ voxels: z }, A) => [A, S(z)])
      ), g = (z) => ({ models: _, colors: b, root: z });
      if (!l.nTRN) return g({ translation: [0, 0, 0], model: 0 });
      const L = (z) => new Map(z.map((A) => [A.id, A])), m = L(l.nTRN), E = L(l.nGRP), w = L(l.nSHP), T = (z) => z.split(" ").map((A) => +A), U = ({ child: z, transfo: A }) => {
        const N = E.get(z) || w.get(z), k = { translation: T(A.get("_t") || "0 0 0") };
        return N.model ? k.model = N.model.id : k.children = N.ids.map((W) => U(m.get(W))), k;
      };
      return g(U(m.get(0)));
    };
    const s = await fetch(t), n = new Uint8Array(await s.arrayBuffer()), r = o(n), a = r.colors;
    r.models.forEach((c, h, l) => {
      let u = [];
      c.colorMap.forEach((p, d) => {
        u[d] = parseInt("0xff" + p, 16);
      }), c.voxels.forEach((p) => {
        let d = u[p[3]].toString(16).slice(2), R = a.get(d).map((M) => M / 255);
        R = R.map((M) => N0(M));
        let y = this.rgbToHex(...R);
        this.setVoxel(p[0], p[2], -p[1], [y, 0]);
      });
    }), this.createVoxelMesh(), this.center();
  }
  saveVOX(t = "model.vox") {
    new D0().save(this, t);
  }
  // saveGLB( filename = 'voxelMesh.glb' )
  // {
  //     const world = this.toVoxelWorld();
  //     saveGLB( world, filename );
  // }
  // convert to VoxelWorld
  // toVoxelWorld()
  // // NOTE*: need to import VoxelWorld
  // {
  //     const aVoxData = this.geometry.attributes['aVoxData'].array;
  //     const voxDim = this.voxDim;
  //     const world = new VoxelWorld();
  //     for( let i = 0, l = aVoxData.length; i < l; i += voxDim )
  //     {
  //         const vp = aVoxData[ i ];
  //         const vc = aVoxData[ i + 1 ];
  //         const [x,y,z] = VoxelMesh.get_xyz( vp );
  //         const hexCol  = VoxelMesh.get_col( vc );
  //         world.setVoxel( x, y, z, hexCol );
  //     }
  //     world.createAllChunks();
  //     return world;
  // }
  // simulation (XPBD)
  getTrimesh() {
    var e;
    const t = (e = this.geometry.attributes.aVoxData) == null ? void 0 : e.array;
    if (t) {
      const o = [], s = [], n = [];
      let r = 0;
      const a = new Array(8), i = new Array(8), c = /* @__PURE__ */ new Map(), h = this.voxDim, l = this.position.x, u = this.position.y, p = this.position.z, d = this.scale.x, R = this.scale.y, y = this.scale.z;
      for (let M = 0, x = t.length; M < x; M += h) {
        const [v, V, O] = C.get_xyz(t[M]), b = C.get_col(t[M + 1]);
        i[0] = [v, V + 1, O], i[1] = [v, V, O], i[2] = [v, V + 1, O + 1], i[3] = [v, V, O + 1], i[4] = [v + 1, V + 1, O + 1], i[5] = [v + 1, V, O + 1], i[6] = [v + 1, V + 1, O], i[7] = [v + 1, V, O];
        for (let _ = 0; _ < 8; _++) {
          const g = C.get_vp(...i[_]), L = c.get(g);
          L === void 0 ? (c.set(g, r), a[_] = r++, o.push(
            l + d * i[_][0],
            u + R * i[_][1],
            p + y * i[_][2]
          ), s.push(
            (b >> 16 & 255) / 255,
            (b >> 8 & 255) / 255,
            (b & 255) / 255
          )) : a[_] = L;
        }
        const S = [
          [a[1], a[2], a[6], a[0]],
          [a[1], a[5], a[2], a[3]],
          [a[2], a[5], a[6], a[4]],
          [a[1], a[6], a[5], a[7]]
        ];
        for (let _ = 0; _ < 4; _++) {
          const [g, L, m, E] = S[_];
          n.push(g, L, E, L, m, E, m, g, E);
        }
      }
      return { verts: o, triIds: n, cols: s };
    }
    return null;
  }
  getTetrahedra() {
    var e;
    const t = (e = this.geometry.attributes.aVoxData) == null ? void 0 : e.array;
    if (t) {
      const o = [], s = [], n = [];
      let r = 0;
      const a = new Array(8), i = new Array(8), c = /* @__PURE__ */ new Map(), h = this.voxDim, l = this.position.x, u = this.position.y, p = this.position.z, d = this.scale.x, R = this.scale.y, y = this.scale.z;
      for (let M = 0, x = t.length; M < x; M += h) {
        const [v, V, O] = C.get_xyz(t[M]);
        i[0] = [v, V + 1, O], i[1] = [v, V, O], i[2] = [v, V + 1, O + 1], i[3] = [v, V, O + 1], i[4] = [v + 1, V + 1, O + 1], i[5] = [v + 1, V, O + 1], i[6] = [v + 1, V + 1, O], i[7] = [v + 1, V, O];
        for (let S = 0; S < 8; S++) {
          const _ = C.get_vp(...i[S]), g = c.get(_);
          g === void 0 ? (c.set(_, r), a[S] = r++, o.push(
            l + d * i[S][0],
            u + R * i[S][1],
            p + y * i[S][2]
          )) : a[S] = g;
        }
        const b = [
          [a[1], a[2], a[6], a[0]],
          [a[1], a[5], a[2], a[3]],
          [a[2], a[5], a[6], a[4]],
          [a[1], a[6], a[5], a[7]]
        ];
        for (let S = 0; S < 4; S++) {
          const [_, g, L, m] = b[S];
          s.push(_, g, L, m), n.push(m, _, m, g, m, L, _, g, g, L, L, _);
        }
      }
      return { verts: o, tetIds: s, edgeIds: n };
    }
    return null;
  }
  // motion
  setMotion(t) {
    this.motion = t;
  }
  updateMotion(t) {
    this.motion.update(t), this.geometry.attributes.aVoxData.needsUpdate = !0;
  }
  // update
  update(t, e) {
    this.motion && this.updateMotion(e);
  }
  // event
  setupEventListeners() {
    const t = this;
    t.isShiftDown = !1, document.addEventListener("pointermove", e), document.addEventListener("pointerdown", o), window.addEventListener("keydown", s, !0), window.addEventListener("keyup", n, !0);
    function e(r) {
      const a = this.threefy, i = a.camera, c = a.raycaster, h = a.mouseMovePosition, l = [];
      if (c.setFromCamera(h, i), t.raycast(c, l), l.length > 0) {
        const { point: u, normal: p } = l[0];
        t.__drawXVoxel(u, p);
      }
    }
    function o(r) {
      const a = this.threefy, i = a.camera, c = a.raycaster, h = a.mouseMovePosition, l = [];
      if (c.setFromCamera(h, i), t.raycast(c, l), l.length > 0) {
        const { point: u, normal: p } = l[0];
        t.isShiftDown ? t.__deleteVoxel(u, p) : t.__addVoxel(u, p);
      }
    }
    function s(r) {
      switch (r.keyCode) {
        case 16:
          t.isShiftDown = !0;
          break;
      }
    }
    function n(r) {
      switch (r.keyCode) {
        case 16:
          t.isShiftDown = !1;
          break;
      }
    }
  }
};
// offsets of voxels connected to 6 faces
j(C, "Faces", ["nzz", "pzz", "znz", "zpz", "zzn", "zzp"]), // offsets of voxels connected to 12 edges
j(C, "Edges", ["znn", "zpn", "znp", "zpp", "nzn", "nzp", "pzn", "pzp", "nnz", "pnz", "npz", "ppz"]), // offsets of voxels connected to 8 vertices
j(C, "Vertices", ["nnn", "pnn", "npn", "ppn", "nnp", "pnp", "npp", "ppp"]);
let i0 = C;
const Z = new p0(), a0 = (f, t = 0, e = 1) => Math.max(t, Math.min(e, f)), B0 = (f, t, e) => e <= f ? 0 : e >= t ? 1 : (e = (e - f) / (t - f), e * e * (3 - 2 * e)), u0 = (f, t) => f + Math.random() * (t - f), U0 = (f) => {
  let t;
  do
    Z.x = u0(-f, f), Z.y = u0(-f, f), t = Z.length();
  while (t > f);
  return Z;
}, j0 = (f) => {
  const t = document.createElement("canvas"), e = t.getContext("2d"), o = f.image;
  t.width = o.width, t.height = o.height, e.drawImage(o, 0, 0);
  const n = e.getImageData(0, 0, o.width, o.height).data, r = new Float32Array(o.width * o.height);
  for (let a = 0, i = 0, c = n.length; i < c; i += 4)
    r[a++] = (n[i] + n[i + 1] + n[i + 2]) / 3;
  return { elevations: r, width: o.width, height: o.height };
};
class D {
  constructor(t = {}) {
    const e = {};
    e.octaves = t.octaves || 1, e.scale = t.scale || 256, e.persistence = t.persistence || 0.5, e.lacunarity = t.lacunarity || 2, e.exponentiation = t.exponentiation || 1, e.height = t.height || 1, e.range = t.range || [0, 1], e.ridged = t.ridged || !1, this.parameters = e, this.snoise = new b0();
  }
  get(t, e, o) {
    const s = this.parameters, n = 2 ** -s.persistence, r = t / s.scale, a = e / s.scale, i = o / s.scale, c = this.snoise;
    let h = 1, l = 1, u = 0, p = 0;
    for (let d = 0; d < s.octaves; d++) {
      let R = c.noise3d(r * l, a * l, i * l);
      p += R * h, u += h, h *= n, l *= s.lacunarity;
    }
    if (p /= u, p = s.ridged ? 1 - Math.abs(p) : p * 0.5 + 0.5, p = Math.pow(p, s.exponentiation), s.range) {
      const d = s.range;
      p = d[0] + (d[1] - d[0]) * p;
    }
    return p * s.height;
  }
}
class X0 {
  constructor(t = 128) {
    this.maxHeight = t, this.WATER_LEVEL = t * 0.1, this.SAND_LEVEL = t * 0.15, this.GRASS_LEVEL = t * 0.5, this.SNOW_LEVEL = t * 0.9, this.WATER_HEXCOL = 8421631, this.SAND_HEXCOL = 16777088, this.GRASS_HEXCOL = 4259648, this.DIRT_HEXCOL = 7299681, this.SNOW_HEXCOL = 16777215, this.STONE_HEXCOL = 4210752, this.HILLS_HEXCOL = 4259648, this.TRUNK_HEXCOL = 7881772, this.LEAF_HEXCOL = 2463422, this.MOON_HEXCOL = 16054e3, this.WATER_COLOR = [this.WATER_HEXCOL], this.SAND_COLOR = [this.SAND_HEXCOL], this.GRASS_COLOR = [this.GRASS_HEXCOL], this.DIRT_COLOR = [this.DIRT_HEXCOL], this.SNOW_COLOR = [this.SNOW_HEXCOL], this.STONE_COLOR = [this.STONE_HEXCOL], this.HILLS_COLOR = [this.HILLS_HEXCOL], this.TRUNK_COLOR = [this.TRUNK_HEXCOL], this.LEAF_COLOR = [this.LEAF_HEXCOL], this.MOON_COLOR = [this.MOON_HEXCOL];
  }
}
class H0 {
  constructor(t) {
    this.terrainDB = t, this.elevation = new D({
      octaves: 6,
      scale: 512,
      // 128 256 512 1024
      persistence: 0.4,
      exponentiation: 2.65,
      height: 128
    }), this.moisture = new D({
      octaves: 3,
      scale: 512,
      persistence: 0.5,
      exponentiation: 2.1,
      height: 128
    });
  }
  biomeColor(t, e) {
    const o = this.terrainDB;
    let s;
    return t < o.WATER_LEVEL ? s = o.WATER_COLOR : t < o.SAND_LEVEL ? s = o.SAND_COLOR : t < o.GRASS_LEVEL ? s = o.GRASS_COLOR : t < o.SNOW_LEVEL ? e < 0.1 ? s = o.STONE_COLOR : e < 0.25 ? s = o.DIRT_COLOR : s = o.HILLS_COLOR : s = o.SNOW_COLOR, s;
  }
  get(t, e) {
    const o = this.elevation.get(t, 0, e), s = this.moisture.get(t, 0, e);
    return [o, this.biomeColor(o, s)];
  }
}
class P0 {
  constructor(t) {
    this.terrainDB = t, this.mountain1 = new D({
      octaves: 3,
      scale: 128,
      exponentiation: 7,
      height: 128
    }), this.mountain2 = new D({
      octaves: 5,
      // 10
      scale: 512,
      exponentiation: 7,
      height: 128,
      ridged: !0
    }), this.roll = new D({
      octaves: 3,
      scale: 32,
      exponentiation: 7,
      height: 1
    });
  }
  biomeColor(t, e, o) {
    const s = this.terrainDB;
    return t < s.WATER_LEVEL ? s.WATER_COLOR : t < s.SAND_LEVEL ? s.SAND_COLOR : t < s.GRASS_LEVEL * o ? s.GRASS_COLOR : t < s.SNOW_LEVEL * o ? s.STONE_COLOR : s.SNOW_COLOR;
  }
  get(t, e) {
    let o = this.mountain1.get(t, 3, e), s = this.mountain2.get(t, 11, e);
    const n = this.roll.get(t, 13, e) * 0.8 + 0.2, r = B.lerp(o, s, n), a = this.roll.get(t, 17, e) * 0.2 + 0.8, i = B.lerp(0, r, a), c = this.roll.get(t, 7, e) * 0.4 + 0.6;
    return [i, this.biomeColor(i, null, c)];
  }
}
class d0 {
  constructor(t) {
    this.terrainDB = t, this.terrain = new D({
      octaves: 6,
      scale: 512,
      exponentiation: 6,
      height: 64,
      ridged: !0
    }), this.height = new D({
      octaves: 1,
      scale: 64,
      exponentiation: 1,
      height: 1,
      range: [0.25, 1]
    }), this.roll = new D({
      octaves: 2,
      scale: 8,
      exponentiation: 1,
      height: 1
    });
  }
  get(t, e) {
    const o = this.terrain.get(t, 0, e) * this.height.get(t, 0, e), s = this.terrainDB, r = this.roll.get(t, 0, e) > o / 32 ? s.DIRT_COLOR : s.STONE_COLOR;
    return [o, r];
  }
}
class k0 {
  constructor(t) {
    this.terrainDB = t, this.ground = new D({
      octaves: 4,
      scale: 512,
      exponentiation: 6,
      height: 1,
      range: [-1, 1]
    }), this.height = new D({
      octaves: 3,
      scale: 512,
      exponentiation: 1,
      height: 64
    });
  }
  get(t, e) {
    const o = this.ground.get(t, 0, e), s = this.ground.get(t, 1, e);
    return [this.height.get(t + o, 0, e + s), this.terrainDB.SAND_COLOR];
  }
}
class r0 {
  constructor(t) {
    this.terrainDB = t, this.smHeight = new D({
      octaves: 5,
      scale: 512,
      exponentiation: 6,
      height: 3
    }), this.lgHeight = new D({
      octaves: 3,
      scale: 1024,
      exponentiation: 1,
      height: 128
    }), this.plateaus = new D({
      octaves: 4,
      scale: 512,
      exponentiation: 2,
      height: 1
    }), this.plateausNum = new D({
      octaves: 4,
      scale: 256,
      exponentiation: 1,
      height: 5
    }), this.moisture = new D({
      octaves: 3,
      scale: 128,
      exponentiation: 4,
      height: 1
    });
  }
  biomeColor(t, e) {
    const o = this.terrainDB;
    let s;
    return t < o.WATER_LEVEL ? s = o.WATER_COLOR : t < o.SAND_LEVEL ? s = o.SAND_COLOR : t < o.GRASS_LEVEL ? s = o.GRASS_COLOR : t < o.SNOW_LEVEL ? e < 0.1 ? s = o.STONE_COLOR : e < 0.25 ? s = o.DIRT_COLOR : s = o.HILLS_COLOR : s = o.SNOW_COLOR, s;
  }
  get(t, e) {
    const o = this.lgHeight.get(t, 0, e);
    let s = o * this.smHeight.get(t, 0, e) + 10;
    if (this.plateaus.get(t, 0, e) > 0.25) {
      const r = Math.round(10 + this.plateausNum.get(t, 0, e)), a = Math.round(o / r);
      s = Math.round(s / a) * a;
    }
    const n = this.moisture.get(t, 0, e);
    return [s, this.biomeColor(s, n)];
  }
}
class v0 {
  constructor(t, e = [0, 0]) {
    this.terrainDB = t, this.offset = e, this.moon = new D({
      octaves: 5,
      scale: 1024,
      exponentiation: 4,
      height: 1
    }), this.crater = new D({
      octaves: 1,
      scale: 0.99,
      exponentiation: 1,
      height: 1
    }), this.craters = [], this.initCraters(), this._v1 = new F();
  }
  initCraters() {
    for (let e = -128; e <= 128; e += 8)
      for (let o = -128; o <= 128; o += 8) {
        const s = e + this.offset[0], n = o + this.offset[1];
        if (this.crater.get(s, 0, n) > 0.95) {
          const a = Math.min(this.crater.get(s, 1, n) ** 4 * 100, 50) + 4;
          this.craters.push([new F(s, 0, n), a]);
        }
      }
  }
  get(t, e) {
    const o = this.moon.get(t, e, 10), s = this.moon.get(t, e, 20), n = Math.round(this.moon.get(t + o, e + s, 0) * 64), r = this._v1;
    let a = n;
    for (let i = 0; i < this.craters.length; ++i) {
      const c = r.set(t, 0, e), [h, l] = this.craters[i], u = h.distanceTo(c), p = l;
      if (u < p * 2) {
        const d = l / 4, R = Math.abs(u - (p - d)), M = 1 - a0(R / d) ** 0.5, x = l / 10, v = 1 - a0((u - (p - d * 2)) / d) ** 2;
        a += M * x + v * -(x * 2);
      }
    }
    return [a, this.terrainDB.MOON_COLOR];
  }
}
class G0 {
  constructor(t) {
    this.terrainDB = t, this.moon = new v0(t), this.grass = new r0(t), this.sand = new r0(t), this.rocky = new d0(t), this.biomeType = new D({
      octaves: 1,
      scale: 1,
      exponentiation: 1,
      height: 4
    }), this.roll = new D({
      octaves: 1,
      scale: 8,
      exponentiation: 1,
      height: 1
    });
  }
  get(t, e) {
    const o = this.terrainDB, s = 128, n = [Math.floor(t / s), Math.floor(e / s)], r = [n[0] * s, n[1] * s], a = [
      r[0] + s * 0.5,
      r[1] + s * 0.5
    ], i = ((t - a[0]) ** 2 + (e - a[1]) ** 2) ** 0.5, c = a0((i - s * 0.25) / (s * 0.25)), h = Math.round(this.biomeType.get(n[0], 0, n[1]));
    let l = null;
    return h == 0 ? l = this.rocky.get(t, e) : h == 1 ? l = this.sand.get(t, e) : h == 2 ? l = this.grass.get(t, e) : h == 3 ? l = [15, o.SNOW_COLOR] : h == 4 && (l = this.moon.get(t, e)), l[0] = B.lerp(l[0], 0, B0(0, 1, c)), l;
  }
}
const $0 = (f) => {
  function t(y, M, x, v) {
    const V = M, [O, b] = h.get(x, v), S = V.TRUNK_COLOR, _ = V.LEAF_COLOR, g = B.randInt(3, 5);
    for (let E = 0; E < g; E++)
      y.setVoxel(x, O + E, v, S);
    const L = 2;
    for (let E = 0; E < L; E++)
      for (let w = -2; w <= 2; w++)
        for (let T = -2; T <= 2; T++)
          Math.abs(T) == 2 && Math.abs(w) == 2 || y.setVoxel(x + T, O + g + E, v + w, _);
    const m = 2;
    for (let E = 0; E < m; E++)
      for (let w = -1; w <= 1; w++)
        for (let T = -1; T <= 1; T++)
          Math.abs(T) == 1 && Math.abs(w) == 1 || y.setVoxel(x + T, O + g + L + E, v + w, _);
  }
  function e(y, M, x, v) {
    const V = M, [O, b] = h.get(x, v), S = B.randInt(6, 10), _ = B.randInt(3, 5), g = [
      [0, -1],
      [0, 1],
      [-1, -1],
      [-1, 0],
      [-1, 1],
      [1, -1],
      [1, 0],
      [1, 1]
    ];
    for (let L = 0; L < S; L++)
      L < _ ? y.setVoxel(x, O + L, v, V.TRUNK_COLOR) : (y.setVoxel(x, O + L, v, V.LEAF_COLOR), g.forEach((m) => {
        Math.random() > 0.5 || y.setVoxel(x + m[0], O + L, v + m[1], V.LEAF_COLOR);
      }));
  }
  function o(y, M, x, v) {
    const V = M, [O, b] = h.get(x, v), S = B.randInt(6, 9), _ = O + S, g = B.randInt(2, 4), L = (m, E, w, T) => m * m + E * E + w * w <= T * T;
    for (let m = 0; m < S; m++)
      y.setVoxel(x, O + m, v, V.TRUNK_COLOR);
    for (let m = -g; m <= g; m++)
      for (let E = -g; E <= g; E++)
        for (let w = -g; w <= g; w++)
          L(m, E, w, g) && y.setVoxel(x + m, _ + E, v + w, V.LEAF_COLOR);
  }
  function s(y, M, x, v) {
    const V = M, [O, b] = h.get(x, v), S = B.randInt(6, 9), _ = O + S, g = B.randInt(5, 8), L = B.randInt(2, 6);
    for (let m = 0; m < S; m++)
      y.setVoxel(x, O + m, v, V.TRUNK_COLOR), m % 2 === 0 ? (y.setVoxel(x - 1, O + m, v, V.TRUNK_COLOR), y.setVoxel(x + 1, O + m, v, V.TRUNK_COLOR)) : (y.setVoxel(x, O + m, v - 1, V.TRUNK_COLOR), y.setVoxel(x, O + m, v + 1, V.TRUNK_COLOR));
    for (let m = 0; m < g; m++) {
      y.setVoxel(x, _ + m, v, V.LEAF_COLOR);
      for (let E = 0; E < 16; E++) {
        const w = U0(L);
        y.setVoxel(x + w.x, _ + m, v + w.y, V.LEAF_COLOR);
      }
    }
  }
  function n(y, M, x, v) {
    switch (B.randInt(1, 4)) {
      case 1:
        t(y, M, x, v);
        break;
      case 2:
        e(y, M, x, v);
        break;
      case 3:
        o(y, M, x, v);
        break;
      case 4:
        s(y, M, x, v);
        break;
    }
  }
  const { selectTerrain: r, radius: a, atlas: i } = f, c = new X0();
  i && (c.WATER_COLOR.push(0), c.SAND_COLOR.push(1), c.GRASS_COLOR.push(2), c.DIRT_COLOR.push(3), c.SNOW_COLOR.push(4), c.STONE_COLOR.push(5), c.HILLS_COLOR.push(6), c.TRUNK_COLOR.push(7), c.LEAF_COLOR.push(8), c.MOON_COLOR.push(9));
  const h = r === 0 ? new H0(c) : r === 1 ? new P0(c) : r === 2 ? new d0(c) : r === 3 ? new k0(c) : r === 4 ? new r0(c) : r === 5 ? new v0(c) : r === 6 ? new G0(c) : null, l = [], u = c, p = 256, d = 256, R = a;
  for (let y = -R; y < R; y++)
    for (let M = -R; M < R; M++) {
      const x = new i0();
      i && x.setAtlasTexture(i);
      let v = p * M, V = d * y;
      for (let O = 0; O < d; O++)
        for (let b = 0; b < p; b++) {
          const S = v + b, _ = V + O;
          let [g, L] = h.get(S, _);
          if (g = Math.round(g), g > 255 && console.log("Warning: terrain height > 255"), x.setVoxel(S, g, _, L), L !== u.WATER_COLOR) {
            let E = g;
            for (let w = -1; w <= 1; w++)
              for (let T = -1; T <= 1; T++) {
                const [U, z] = h.get(S + T, _ + w);
                E = Math.min(U, E);
              }
            if (E < g)
              for (let w = E + 1; w < g; w++)
                x.setVoxel(S, w, _, u.DIRT_COLOR);
          }
          if (b >= 9 && b < p - 9 && O >= 9 && O < d - 9 && Math.random() < 0.01) {
            const E = S + B.randInt(-3, 3), w = _ + B.randInt(-3, 3), [T, U] = h.get(E, w);
            U[1] == u.GRASS_COLOR[1] && n(x, u, E, w);
          }
        }
      x.createVoxelMesh(), x.name = `voxelMesh(${M},${y})`, x.frustumCulled = !1, l.push(x);
    }
  return l;
};
export {
  X0 as TerrainDB,
  D0 as VOXExporter,
  i0 as VoxelMesh,
  $0 as createVoxelTerrains,
  j0 as tex2heights
};
